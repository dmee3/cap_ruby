# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `capybara` gem.
# Please instead update this file by running `bin/tapioca gem capybara`.


# source://capybara//lib/capybara/session/config.rb#4
module Capybara
  class << self
    # Parse raw html into a document using Nokogiri, and adjust textarea contents as defined by the spec.
    #
    # @param html [String] The raw html
    # @return [Nokogiri::HTML::Document] HTML document
    #
    # source://capybara//lib/capybara.rb#367
    def HTML(html); end

    # Add a new selector to Capybara. Selectors can be used by various methods in Capybara
    # to find certain elements on the page in a more convenient way. For example adding a
    # selector to find certain table rows might look like this:
    #
    #     Capybara.add_selector(:row) do
    #       xpath { |num| ".//tbody/tr[#{num}]" }
    #     end
    #
    # This makes it possible to use this selector in a variety of ways:
    #
    #     find(:row, 3)
    #     page.find('table#myTable').find(:row, 3).text
    #     page.find('table#myTable').has_selector?(:row, 3)
    #     within(:row, 3) { expect(page).to have_content('$100.000') }
    #
    # Here is another example:
    #
    #     Capybara.add_selector(:id) do
    #       xpath { |id| XPath.descendant[XPath.attr(:id) == id.to_s] }
    #     end
    #
    # Note that this particular selector already ships with Capybara.
    #
    # @param name [Symbol] The name of the selector to add
    # @yield A block executed in the context of the new {Capybara::Selector}
    #
    # source://capybara//lib/capybara.rb#165
    def add_selector(name, &block); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def always_include_port(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def always_include_port=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def app(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def app=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def app_host(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def app_host=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def asset_host(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def asset_host=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def automatic_label_click(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def automatic_label_click=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def automatic_reload(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def automatic_reload=(*args, **_arg1, &block); end

    # Configure Capybara to suit your needs.
    #
    #     Capybara.configure do |config|
    #       config.run_server = false
    #       config.app_host   = 'http://www.google.com'
    #     end
    #
    # === Configurable options
    #
    # [app_host = String/nil]             The default host to use when giving a relative URL to visit, must be a valid URL e.g. http://www.example.com
    # [always_include_port = Boolean]     Whether the Rack server's port should automatically be inserted into every visited URL unless another port is explicitly specified (Default: false)
    # [asset_host = String]               Where dynamic assets are hosted - will be prepended to relative asset locations if present (Default: nil)
    # [run_server = Boolean]              Whether to start a Rack server for the given Rack app (Default: true)
    # [raise_server_errors = Boolean]     Should errors raised in the server be raised in the tests? (Default: true)
    # [server_errors = Array\<Class\>]    Error classes that should be raised in the tests if they are raised in the server and Capybara.raise_server_errors is true (Default: [StandardError])
    # [default_selector = :css/:xpath]    Methods which take a selector use the given type by default (Default: :css)
    # [default_max_wait_time = Numeric]   The maximum number of seconds to wait for asynchronous processes to finish (Default: 2)
    # [ignore_hidden_elements = Boolean]  Whether to ignore hidden elements on the page (Default: true)
    # [automatic_reload = Boolean]        Whether to automatically reload elements as Capybara is waiting (Default: true)
    # [save_path = String]  Where to put pages saved through save_(page|screenshot), save_and_open_(page|screenshot) (Default: Dir.pwd)
    # [wait_on_first_by_default = Boolean]   Whether Node#first defaults to Capybara waiting behavior for at least 1 element to match (Default: false)
    # [automatic_label_click = Boolean]   Whether Node#choose, Node#check, Node#uncheck will attempt to click the associated label element if the checkbox/radio button are non-visible (Default: false)
    # [enable_aria_label = Boolean]  Whether fields, links, and buttons will match against aria-label attribute (Default: false)
    # [reuse_server = Boolean]  Reuse the server thread between multiple sessions using the same app object (Default: true)
    # [threadsafe = Boolean]  Whether sessions can be configured individually (Default: false)
    # [server = Symbol]  The name of the registered server to use when running the app under test (Default: :webrick)
    #
    # === DSL Options
    #
    # when using capybara/dsl, the following options are also available:
    #
    # [default_driver = Symbol]           The name of the driver to use by default. (Default: :rack_test)
    # [javascript_driver = Symbol]        The name of a driver to use for JavaScript enabled tests. (Default: :selenium)
    #
    # @yield [ConfigureDeprecator.new(config)]
    #
    # source://capybara//lib/capybara.rb#96
    def configure; end

    # @return [Symbol] The name of the driver currently in use
    #
    # source://capybara//lib/capybara.rb#248
    def current_driver; end

    # source://capybara//lib/capybara.rb#257
    def current_driver=(name); end

    # The current Capybara::Session based on what is set as Capybara.app and Capybara.current_driver
    #
    # @return [Capybara::Session] The currently used session
    #
    # source://capybara//lib/capybara.rb#303
    def current_session; end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def default_driver(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def default_driver=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def default_host(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def default_host=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def default_max_wait_time(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def default_max_wait_time=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def default_selector(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def default_selector=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def default_wait_time(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def default_wait_time=(*args, **_arg1, &block); end

    # source://capybara//lib/capybara.rb#187
    def drivers; end

    # source://forwardable/1.3.2/forwardable.rb#229
    def enable_aria_label(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def enable_aria_label=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def exact(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def exact=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def exact_options(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def exact_options=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def exact_text(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def exact_text=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def ignore_hidden_elements(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def ignore_hidden_elements=(*args, **_arg1, &block); end

    # @private
    #
    # source://capybara//lib/capybara.rb#379
    def included(base); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def javascript_driver(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def javascript_driver=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def match(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def match=(*args, **_arg1, &block); end

    # @return [Symbol] The name of the driver currently in use
    #
    # source://capybara//lib/capybara.rb#248
    def mode; end

    # Modify a selector previously created by {Capybara.add_selector}.
    # For example, adding a new filter to the :button selector to filter based on
    # button style (a class) might look like this
    #
    #     Capybara.modify_selector(:button) do
    #       filter (:style, valid_values: [:primary, :secondary]) { |node, style| node[:class].split.include? "btn-#{style}" }
    #     end
    #
    # @param name [Symbol] The name of the selector to modify
    # @yield A block executed in the context of the existing {Capybara::Selector}
    #
    # source://capybara//lib/capybara.rb#183
    def modify_selector(name, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def raise_server_errors(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def raise_server_errors=(*args, **_arg1, &block); end

    # Register a new driver for Capybara.
    #
    #     Capybara.register_driver :rack_test do |app|
    #       Capybara::RackTest::Driver.new(app)
    #     end
    #
    # @param name [Symbol] The name of the new driver
    # @yield [app] This block takes a rack app and returns a Capybara driver
    # @yieldparam app [<Rack>] The rack application that this driver runs against. May be nil.
    # @yieldreturn [Capybara::Driver::Base] A Capybara driver instance
    #
    # source://capybara//lib/capybara.rb#113
    def register_driver(name, &block); end

    # Register a new server for Capybara.
    #
    #     Capybara.register_server :webrick do |app, port, host|
    #       require 'rack/handler/webrick'
    #       Rack::Handler::WEBrick.run(app, ...)
    #     end
    #
    # @param name [Symbol] The name of the new driver
    # @yield [app, port, host] This block takes a rack app and a port and returns a rack server listening on that port
    # @yieldparam app [<Rack>] The rack application that this server will contain.
    # @yieldparam port The port number the server should listen on
    # @yieldparam host The host/ip to bind to
    # @yieldreturn [Capybara::Driver::Base] A Capybara driver instance
    #
    # source://capybara//lib/capybara.rb#133
    def register_server(name, &block); end

    # Reset sessions, cleaning out the pool of sessions. This will remove any session information such
    # as cookies.
    #
    # source://capybara//lib/capybara.rb#312
    def reset!; end

    # Reset sessions, cleaning out the pool of sessions. This will remove any session information such
    # as cookies.
    #
    # source://capybara//lib/capybara.rb#312
    def reset_sessions!; end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def reuse_server(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def reuse_server=(*args, **_arg1, &block); end

    # Runs Capybara's default server for the given application and port
    # under most circumstances you should not have to call this method
    # manually.
    #
    # @param app [Rack Application] The rack application to run
    # @param port [Integer] The port to run the application on
    #
    # source://capybara//lib/capybara.rb#240
    def run_default_server(app, port); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def run_server(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def run_server=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def save_and_open_page_path(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def save_and_open_page_path=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def save_path(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def save_path=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def server(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def server=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def server_errors(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def server_errors=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def server_host(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def server_host=(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def server_port(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def server_port=(*args, **_arg1, &block); end

    # source://capybara//lib/capybara.rb#191
    def servers; end

    # The current session name.
    #
    # @return [Symbol] The name of the currently used session.
    #
    # source://capybara//lib/capybara.rb#324
    def session_name; end

    # source://capybara//lib/capybara.rb#332
    def session_name=(name); end

    # source://capybara//lib/capybara.rb#375
    def session_options; end

    # Wraps the given string, which should contain an HTML document or fragment
    # in a {Capybara::Node::Simple} which exposes all {Capybara::Node::Matchers},
    # {Capybara::Node::Finders} and {Capybara::Node::DocumentMatchers}. This allows you to query
    # any string containing HTML in the exact same way you would query the current document in a Capybara
    # session.
    #
    # Example: A single element
    #
    #     node = Capybara.string('<a href="foo">bar</a>')
    #     anchor = node.first('a')
    #     anchor[:href] #=> 'foo'
    #     anchor.text #=> 'bar'
    #
    # Example: Multiple elements
    #
    #     node = Capybara.string <<-HTML
    #       <ul>
    #         <li id="home">Home</li>
    #         <li id="projects">Projects</li>
    #       </ul>
    #     HTML
    #
    #     node.find('#projects').text # => 'Projects'
    #     node.has_selector?('li#home', text: 'Home')
    #     node.has_selector?('#projects')
    #     node.find('ul').find('li:first-child').text # => 'Home'
    #
    # @param html [String] An html fragment or document
    # @return [Capybara::Node::Simple] A node which has Capybara's finders and matchers
    #
    # source://capybara//lib/capybara.rb#227
    def string(html); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def threadsafe(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def threadsafe=(*args, **_arg1, &block); end

    # Use the default driver as the current driver
    #
    # source://capybara//lib/capybara.rb#269
    def use_default_driver; end

    # Yield a block using a specific driver
    #
    # source://capybara//lib/capybara.rb#277
    def using_driver(driver); end

    # Yield a block using a specific session name.
    #
    # source://capybara//lib/capybara.rb#344
    def using_session(name); end

    # Yield a block using a specific wait time
    #
    # source://capybara//lib/capybara.rb#289
    def using_wait_time(seconds); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def visible_text_only(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def visible_text_only=(*args, **_arg1, &block); end

    # See {Capybara.configure}
    #
    # source://forwardable/1.3.2/forwardable.rb#229
    def wait_on_first_by_default(*args, **_arg1, &block); end

    # source://forwardable/1.3.2/forwardable.rb#229
    def wait_on_first_by_default=(*args, **_arg1, &block); end

    private

    # source://capybara//lib/capybara.rb#385
    def config; end

    # source://capybara//lib/capybara.rb#389
    def session_pool; end
  end
end

# source://capybara//lib/capybara.rb#14
class Capybara::Ambiguous < ::Capybara::ElementNotFound; end

# source://capybara//lib/capybara.rb#9
class Capybara::CapybaraError < ::StandardError; end

# source://capybara//lib/capybara/config.rb#6
class Capybara::Config
  extend ::Forwardable

  # @return [Config] a new instance of Config
  #
  # source://capybara//lib/capybara/config.rb#20
  def initialize; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def always_include_port(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def always_include_port=(*args, **_arg1, &block); end

  # Returns the value of attribute app.
  #
  # source://capybara//lib/capybara/config.rb#11
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  #
  # source://capybara//lib/capybara/config.rb#11
  def app=(_arg0); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def app_host(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def app_host=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def asset_host(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def asset_host=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def automatic_label_click(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def automatic_label_click=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def automatic_reload(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def automatic_reload=(*args, **_arg1, &block); end

  # @return [Symbol] The name of the driver to use by default
  #
  # source://capybara//lib/capybara/config.rb#80
  def default_driver; end

  # Sets the attribute default_driver
  #
  # @param value the value to set the attribute default_driver to.
  #
  # source://capybara//lib/capybara/config.rb#14
  def default_driver=(_arg0); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_host(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_host=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_max_wait_time(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_max_wait_time=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_selector(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def default_selector=(*args, **_arg1, &block); end

  # @deprecated Use default_max_wait_time instead
  #
  # source://capybara//lib/capybara/config.rb#93
  def default_wait_time; end

  # @deprecated Use default_max_wait_time= instead
  #
  # source://capybara//lib/capybara/config.rb#99
  def default_wait_time=(t); end

  # source://capybara//lib/capybara/config.rb#104
  def deprecate(method, alternate_method, once = T.unsafe(nil)); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def enable_aria_label(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def enable_aria_label=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def exact(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def exact=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def exact_options(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def exact_options=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def exact_text(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def exact_text=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def ignore_hidden_elements(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def ignore_hidden_elements=(*args, **_arg1, &block); end

  # @return [Symbol] The name of the driver used when JavaScript is needed
  #
  # source://capybara//lib/capybara/config.rb#88
  def javascript_driver; end

  # Sets the attribute javascript_driver
  #
  # @param value the value to set the attribute javascript_driver to.
  #
  # source://capybara//lib/capybara/config.rb#14
  def javascript_driver=(_arg0); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def match(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def match=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def raise_server_errors(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def raise_server_errors=(*args, **_arg1, &block); end

  # Returns the value of attribute reuse_server.
  #
  # source://capybara//lib/capybara/config.rb#12
  def reuse_server; end

  # source://capybara//lib/capybara/config.rb#24
  def reuse_server=(bool); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def run_server(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def run_server=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def save_and_open_page_path(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def save_and_open_page_path=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def save_path(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def save_path=(*args, **_arg1, &block); end

  # Return the proc that Capybara will call to run the Rack application.
  # The block returned receives a rack app, port, and host/ip and should run a Rack handler
  # By default, Capybara will try to run webrick.
  #
  # source://capybara//lib/capybara/config.rb#40
  def server(&block); end

  # Set the server to use.
  #
  #     Capybara.server = :webrick
  #     Capybara.server = :puma, { Silent: true }
  #
  # @overload server=
  # @overload server=
  # @see register_server
  #
  # source://capybara//lib/capybara/config.rb#63
  def server=(name); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def server_errors(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def server_errors=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def server_host(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def server_host=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def server_port(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def server_port=(*args, **_arg1, &block); end

  # Returns the value of attribute session_options.
  #
  # source://capybara//lib/capybara/config.rb#13
  def session_options; end

  # Returns the value of attribute threadsafe.
  #
  # source://capybara//lib/capybara/config.rb#12
  def threadsafe; end

  # source://capybara//lib/capybara/config.rb#28
  def threadsafe=(bool); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def visible_text_only(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def visible_text_only=(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def wait_on_first_by_default(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def wait_on_first_by_default=(*args, **_arg1, &block); end
end

# source://capybara//lib/capybara/config.rb#9
Capybara::Config::OPTIONS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://capybara//lib/capybara/config.rb#112
class Capybara::ConfigureDeprecator
  # @api private
  # @return [ConfigureDeprecator] a new instance of ConfigureDeprecator
  #
  # source://capybara//lib/capybara/config.rb#113
  def initialize(config); end

  # @api private
  #
  # source://capybara//lib/capybara/config.rb#117
  def method_missing(m, *args, &block); end

  private

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/config.rb#128
  def respond_to_missing?(m, include_private = T.unsafe(nil)); end
end

# source://capybara//lib/capybara.rb#398
module Capybara::Driver; end

# source://capybara//lib/capybara/driver/base.rb#2
class Capybara::Driver::Base
  # Execute the block, and then accept the modal opened.
  #
  # @option options
  # @option options
  # @option options
  # @param type [:alert, :confirm, :prompt]
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  #
  # source://capybara//lib/capybara/driver/base.rb#120
  def accept_modal(type, options = T.unsafe(nil), &blk); end

  # @deprecated This method is being removed
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/base.rb#157
  def browser_initialized?; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#85
  def close_window(handle); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/base.rb#5
  def current_url; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#69
  def current_window_handle; end

  # Execute the block, and then dismiss the modal opened.
  #
  # @option options
  # @option options
  # @param type [:alert, :confirm, :prompt]
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  #
  # source://capybara//lib/capybara/driver/base.rb#133
  def dismiss_modal(type, options = T.unsafe(nil), &blk); end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#45
  def evaluate_async_script(script, *args); end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#41
  def evaluate_script(script, *args); end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#37
  def execute_script(script, *args); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/base.rb#21
  def find_css(query); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/base.rb#17
  def find_xpath(query); end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#29
  def go_back; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#33
  def go_forward; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/base.rb#25
  def html; end

  # source://capybara//lib/capybara/driver/base.rb#137
  def invalid_element_errors; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#81
  def maximize_window(handle); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/base.rb#148
  def needs_server?; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#105
  def no_such_window_error; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#93
  def open_new_window; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/base.rb#13
  def refresh; end

  # source://capybara//lib/capybara/driver/base.rb#145
  def reset!; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#77
  def resize_window_to(handle, width, height); end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#53
  def response_headers; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#49
  def save_screenshot(path, options = T.unsafe(nil)); end

  # Sets the attribute session
  #
  # @param value the value to set the attribute session to.
  #
  # source://capybara//lib/capybara/driver/base.rb#3
  def session=(_arg0); end

  # source://capybara//lib/capybara/driver/base.rb#152
  def session_options; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#57
  def status_code; end

  # @param frame [Capybara::Node::Element, :parent, :top] The iframe element to switch to
  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#65
  def switch_to_frame(frame); end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#97
  def switch_to_window(handle); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/base.rb#9
  def visit(path); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/base.rb#141
  def wait?; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#89
  def window_handles; end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#73
  def window_size(handle); end

  # @raise [Capybara::NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/base.rb#101
  def within_window(locator); end
end

# source://capybara//lib/capybara/driver/node.rb#4
class Capybara::Driver::Node
  # @return [Node] a new instance of Node
  #
  # source://capybara//lib/capybara/driver/node.rb#7
  def initialize(driver, native); end

  # @raise [NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/node.rb#108
  def ==(other); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#20
  def [](name); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#12
  def all_text; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/node.rb#74
  def checked?; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#42
  def click; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/node.rb#82
  def disabled?; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#50
  def double_click; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#62
  def drag_to(element); end

  # Returns the value of attribute driver.
  #
  # source://capybara//lib/capybara/driver/node.rb#5
  def driver; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#58
  def hover; end

  # source://capybara//lib/capybara/driver/node.rb#102
  def inspect; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/node.rb#90
  def multiple?; end

  # Returns the value of attribute native.
  #
  # source://capybara//lib/capybara/driver/node.rb#5
  def native; end

  # @raise [NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/node.rb#94
  def path; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/node.rb#86
  def readonly?; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#46
  def right_click; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#34
  def select_option; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/node.rb#78
  def selected?; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#54
  def send_keys(*args); end

  # @param value String or Array. Array is only allowed if node has 'multiple' attribute
  # @param options [Hash{}] Driver specific options for how to set a value on a node
  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#30
  def set(value, options = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#66
  def tag_name; end

  # @raise [NotSupportedByDriverError]
  #
  # source://capybara//lib/capybara/driver/node.rb#98
  def trigger(event); end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#38
  def unselect_option; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#24
  def value; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/driver/node.rb#70
  def visible?; end

  # @raise [NotImplementedError]
  #
  # source://capybara//lib/capybara/driver/node.rb#16
  def visible_text; end
end

# source://capybara//lib/capybara.rb#10
class Capybara::DriverNotFoundError < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara.rb#12
class Capybara::ElementNotFound < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara.rb#15
class Capybara::ExpectationNotMet < ::Capybara::ElementNotFound; end

# source://capybara//lib/capybara.rb#16
class Capybara::FileNotFound < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara.rb#11
class Capybara::FrozenInTime < ::Capybara::CapybaraError; end

# @api private
#
# source://capybara//lib/capybara/helpers.rb#7
module Capybara::Helpers
  extend ::Capybara::Helpers

  # A poor man's `pluralize`. Given two declensions, one singular and one
  # plural, as well as a count, this will pick the correct declension. This
  # way we can generate grammatically correct error message.
  #
  # @api private
  # @param singular [String] The singular form of the word
  # @param plural [String] The plural form of the word
  # @param count [Integer] The number of items
  #
  # source://capybara//lib/capybara/helpers.rb#70
  def declension(singular, plural, count); end

  # Injects a `<base>` tag into the given HTML code, pointing to
  # `Capybara.asset_host`.
  #
  # @api private
  # @param html [String] HTML code to inject into
  # @return [String] The modified HTML code
  #
  # source://capybara//lib/capybara/helpers.rb#49
  def inject_asset_host(html, asset_host = T.unsafe(nil)); end

  # @api private
  #
  # source://capybara//lib/capybara/helpers.rb#79
  def monotonic_time; end

  # Normalizes whitespace space by stripping leading and trailing
  # whitespace and replacing sequences of whitespace characters
  # with a single space.
  #
  # @api private
  # @param text [String] Text to normalize
  # @return [String] Normalized text
  #
  # source://capybara//lib/capybara/helpers.rb#19
  def normalize_whitespace(text); end

  # Escapes any characters that would have special meaning in a regexp
  # if text is not a regexp
  #
  # @api private
  # @param text [String] Text to escape
  # @return [String] Escaped text
  #
  # source://capybara//lib/capybara/helpers.rb#31
  def to_regexp(text, regexp_options = T.unsafe(nil), exact = T.unsafe(nil)); end
end

# source://capybara//lib/capybara.rb#19
class Capybara::InfiniteRedirectError < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara.rb#13
class Capybara::ModalNotFound < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara/node/finders.rb#3
module Capybara::Node; end

# source://capybara//lib/capybara/node/actions.rb#4
module Capybara::Node::Actions
  # Find a file field on the page and attach a file given its path. The file field can
  # be found via its name, id or label text.
  #
  #     page.attach_file(locator, '/path/to/file.png')
  #
  # If the driver is capable of executing JavaScript, +attach_file+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param locator [String] Which field to attach the file to
  # @param path [String] The path of the file that will be attached, or an array of paths
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The file field element
  #
  # source://capybara//lib/capybara/node/actions.rb#236
  def attach_file(locator, path, options = T.unsafe(nil)); end

  # Find a check box and mark it as checked. The check box can be found
  # via name, id or label text.
  #
  #     page.check('German')
  #
  # @overload check
  # @return [Capybara::Node::Element] The element checked or the label clicked
  #
  # source://capybara//lib/capybara/node/actions.rb#139
  def check(locator, options = T.unsafe(nil)); end

  # Find a radio button and mark it as checked. The radio button can be found
  # via name, id or label text.
  #
  #     page.choose('Male')
  #
  # @overload choose
  # @return [Capybara::Node::Element] The element chosen or the label clicked
  #
  # source://capybara//lib/capybara/node/actions.rb#116
  def choose(locator, options = T.unsafe(nil)); end

  # Finds a button on the page and clicks it.
  # This can be any \<input> element of type submit, reset, image, button or it can be a
  # \<button> element. All buttons can be found by their id, value, or title. \<button> elements can also be found
  # by their text content, and image \<input> elements by their alt attribute
  #
  # If the driver is capable of executing JavaScript, +click_button+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  #
  # @option options
  # @overload click_button
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The element clicked
  #
  # source://capybara//lib/capybara/node/actions.rb#59
  def click_button(locator = T.unsafe(nil), options = T.unsafe(nil)); end

  # Finds a link by id, text or title and clicks it. Also looks at image
  # alt text inside the link.
  #
  # If the driver is capable of executing JavaScript, +click_link+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  #
  # @option options
  # @overload click_link
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The element clicked
  #
  # source://capybara//lib/capybara/node/actions.rb#41
  def click_link(locator = T.unsafe(nil), options = T.unsafe(nil)); end

  # Finds a button or link and clicks it.  See {Capybara::Node::Actions#click_button} and
  # {Capybara::Node::Actions#click_link} for what locator will match against for each type of element
  # If the driver is capable of executing JavaScript, +click_link_or_button+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  #
  # @option options
  # @overload click_link_or_button
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The element clicked
  #
  # source://capybara//lib/capybara/node/actions.rb#23
  def click_link_or_button(locator = T.unsafe(nil), options = T.unsafe(nil)); end

  # Finds a button or link and clicks it.  See {Capybara::Node::Actions#click_button} and
  # {Capybara::Node::Actions#click_link} for what locator will match against for each type of element
  # If the driver is capable of executing JavaScript, +click_link_or_button+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  #
  # @option options
  # @overload click_link_or_button
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The element clicked
  #
  # source://capybara//lib/capybara/node/actions.rb#23
  def click_on(locator = T.unsafe(nil), options = T.unsafe(nil)); end

  # Locate a text field or text area and fill it in with the given text
  # The field can be found via its name, id or label text.
  #
  #     page.fill_in 'Name', with: 'Bob'
  #
  # @overload fill_in
  # @return [Capybara::Node::Element] The element filled_in
  #
  # source://capybara//lib/capybara/node/actions.rb#86
  def fill_in(locator, options = T.unsafe(nil)); end

  # If `:from` option is present, `select` finds a select box on the page
  # and selects a particular option from it.
  # Otherwise it finds an option inside current scope and selects it.
  # If the select box is a multiple select, +select+ can be called multiple times to select more than
  # one option.
  # The select box can be found via its name, id or label text. The option can be found by its text.
  #
  #     page.select 'March', from: 'Month'
  #
  # If the driver is capable of executing JavaScript, +select+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  #
  # @option options
  # @option options
  # @param value [String] Which option to select
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The option element selected
  #
  # source://capybara//lib/capybara/node/actions.rb#183
  def select(value, options = T.unsafe(nil)); end

  # Find a check box and mark uncheck it. The check box can be found
  # via name, id or label text.
  #
  #     page.uncheck('German')
  #
  # @overload uncheck
  # @return [Capybara::Node::Element] The element unchecked or the label clicked
  #
  # source://capybara//lib/capybara/node/actions.rb#162
  def uncheck(locator, options = T.unsafe(nil)); end

  # Find a select box on the page and unselect a particular option from it. If the select
  # box is a multiple select, +unselect+ can be called multiple times to unselect more than
  # one option. The select box can be found via its name, id or label text.
  #
  #     page.unselect 'March', from: 'Month'
  #
  # If the driver is capable of executing JavaScript, +unselect+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  #
  # @option options
  # @param value [String] Which option to unselect
  # @param options [Hash{:from => String}] The id, name or label of the select box
  # @return [Capybara::Node::Element] The option element unselected
  #
  # source://capybara//lib/capybara/node/actions.rb#206
  def unselect(value, options = T.unsafe(nil)); end

  private

  # source://capybara//lib/capybara/node/actions.rb#294
  def _check_with_label(selector, checked, locator, options); end

  # source://capybara//lib/capybara/node/actions.rb#279
  def _reset_style(element); end

  # source://capybara//lib/capybara/node/actions.rb#261
  def _update_style(element, style); end
end

# A {Capybara::Node::Base} represents either an element on a page through the subclass
# {Capybara::Node::Element} or a document through {Capybara::Node::Document}.
#
# Both types of Node share the same methods, used for interacting with the
# elements on the page. These methods are divided into three categories,
# finders, actions and matchers. These are found in the modules
# {Capybara::Node::Finders}, {Capybara::Node::Actions} and {Capybara::Node::Matchers}
# respectively.
#
# A {Capybara::Session} exposes all methods from {Capybara::Node::Document} directly:
#
#     session = Capybara::Session.new(:rack_test, my_app)
#     session.visit('/')
#     session.fill_in('Foo', with: 'Bar')    # from Capybara::Node::Actions
#     bar = session.find('#bar')                # from Capybara::Node::Finders
#     bar.select('Baz', from: 'Quox')        # from Capybara::Node::Actions
#     session.has_css?('#foobar')               # from Capybara::Node::Matchers
#
# source://capybara//lib/capybara/node/base.rb#25
class Capybara::Node::Base
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Actions
  include ::Capybara::Node::Matchers

  # @return [Base] a new instance of Base
  #
  # source://capybara//lib/capybara/node/base.rb#32
  def initialize(session, base); end

  # Returns the value of attribute base.
  #
  # source://capybara//lib/capybara/node/base.rb#26
  def base; end

  # @api private
  #
  # source://capybara//lib/capybara/node/base.rb#102
  def find_css(css); end

  # @api private
  #
  # source://capybara//lib/capybara/node/base.rb#107
  def find_xpath(xpath); end

  # @deprecated Use query_scope instead
  #
  # source://capybara//lib/capybara/node/base.rb#112
  def parent; end

  # Returns the value of attribute query_scope.
  #
  # source://capybara//lib/capybara/node/base.rb#26
  def query_scope; end

  # overridden in subclasses, e.g. Capybara::Node::Element
  #
  # source://capybara//lib/capybara/node/base.rb#38
  def reload; end

  # Returns the value of attribute session.
  #
  # source://capybara//lib/capybara/node/base.rb#26
  def session; end

  # @api private
  #
  # source://capybara//lib/capybara/node/base.rb#118
  def session_options; end

  # This method is Capybara's primary defence against asynchronicity
  # problems. It works by attempting to run a given block of code until it
  # succeeds. The exact behaviour of this method depends on a number of
  # factors. Basically there are certain exceptions which, when raised
  # from the block, instead of bubbling up, are caught, and the block is
  # re-run.
  #
  # Certain drivers, such as RackTest, have no support for asynchronous
  # processes, these drivers run the block, and any error raised bubbles up
  # immediately. This allows faster turn around in the case where an
  # expectation fails.
  #
  # Only exceptions that are {Capybara::ElementNotFound} or any subclass
  # thereof cause the block to be rerun. Drivers may specify additional
  # exceptions which also cause reruns. This usually occurs when a node is
  # manipulated which no longer exists on the page. For example, the
  # Selenium driver specifies
  # `Selenium::WebDriver::Error::ObsoleteElementError`.
  #
  # As long as any of these exceptions are thrown, the block is re-run,
  # until a certain amount of time passes. The amount of time defaults to
  # {Capybara.default_max_wait_time} and can be overridden through the `seconds`
  # argument. This time is compared with the system time to see how much
  # time has passed. On rubies/platforms which don't support access to a monotonic process clock
  # if the return value of `Time.now` is stubbed out, Capybara will raise `Capybara::FrozenInTime`.
  #
  # @option options
  # @param seconds [Integer] Number of seconds to retry this block
  # @param options [Hash]
  # @raise [Capybara::FrozenInTime] If the return value of `Time.now` appears stuck
  # @return [Object] The result of the given block
  #
  # source://capybara//lib/capybara/node/base.rb#77
  def synchronize(seconds = T.unsafe(nil), options = T.unsafe(nil)); end

  protected

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/base.rb#124
  def catch_error?(error, errors = T.unsafe(nil)); end

  # source://capybara//lib/capybara/node/base.rb#131
  def driver; end
end

# A {Capybara::Document} represents an HTML document. Any operation
# performed on it will be performed on the entire document.
#
# @see Capybara::Node
#
# source://capybara//lib/capybara/node/document.rb#12
class Capybara::Node::Document < ::Capybara::Node::Base
  include ::Capybara::Node::DocumentMatchers

  # source://capybara//lib/capybara/node/document.rb#15
  def inspect; end

  # @return [String] The text of the document
  #
  # source://capybara//lib/capybara/node/document.rb#23
  def text(type = T.unsafe(nil)); end

  # @return [String] The title of the document
  #
  # source://capybara//lib/capybara/node/document.rb#31
  def title; end
end

# source://capybara//lib/capybara/node/document_matchers.rb#4
module Capybara::Node::DocumentMatchers
  # Asserts that the page doesn't have the given title.
  #
  # @option options
  # @option options
  # @overload assert_no_title
  # @overload assert_no_title
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  #
  # source://capybara//lib/capybara/node/document_matchers.rb#29
  def assert_no_title(title, options = T.unsafe(nil)); end

  # Asserts that the page has the given title.
  #
  # @option options
  # @option options
  # @overload assert_title
  # @overload assert_title
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  #
  # source://capybara//lib/capybara/node/document_matchers.rb#18
  def assert_title(title, options = T.unsafe(nil)); end

  # Checks if the page doesn't have the given title.
  #
  # @option options
  # @option options
  # @overload has_no_title?
  # @overload has_no_title?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/document_matchers.rb#51
  def has_no_title?(title, options = T.unsafe(nil)); end

  # Checks if the page has the given title.
  #
  # @option options
  # @option options
  # @overload has_title?
  # @overload has_title?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/document_matchers.rb#39
  def has_title?(title, options = T.unsafe(nil)); end

  private

  # source://capybara//lib/capybara/node/document_matchers.rb#59
  def _verify_title(title, options); end
end

# A {Capybara::Node::Element} represents a single element on the page. It is possible
# to interact with the contents of this element the same as with a document:
#
#     session = Capybara::Session.new(:rack_test, my_app)
#
#     bar = session.find('#bar')              # from Capybara::Node::Finders
#     bar.select('Baz', from: 'Quox')      # from Capybara::Node::Actions
#
# {Capybara::Node::Element} also has access to HTML attributes and other properties of the
# element:
#
#      bar.value
#      bar.text
#      bar[:title]
#
# @see Capybara::Node
#
# source://capybara//lib/capybara/node/element.rb#24
class Capybara::Node::Element < ::Capybara::Node::Base
  # @return [Element] a new instance of Element
  #
  # source://capybara//lib/capybara/node/element.rb#26
  def initialize(session, base, query_scope, query); end

  # Retrieve the given attribute
  #
  #     element[:title] # => HTML title attribute
  #
  # @param attribute [Symbol] The attribute to retrieve
  # @return [String] The value of the attribute
  #
  # source://capybara//lib/capybara/node/element.rb#77
  def [](attribute); end

  # source://capybara//lib/capybara/node/element.rb#33
  def allow_reload!; end

  # Whether or not the element is checked.
  #
  # @return [Boolean] Whether the element is checked
  #
  # source://capybara//lib/capybara/node/element.rb#278
  def checked?; end

  # Click the Element
  #
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#142
  def click; end

  # Whether or not the element is disabled.
  #
  # @return [Boolean] Whether the element is disabled
  #
  # source://capybara//lib/capybara/node/element.rb#298
  def disabled?; end

  # Double Click the Element
  #
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#162
  def double_click; end

  # Drag the element to the given other element.
  #
  #     source = page.find('#foo')
  #     target = page.find('#bar')
  #     source.drag_to(target)
  #
  # @param node [Capybara::Node::Element] The element to drag to
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#356
  def drag_to(node); end

  # Hover on the Element
  #
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#248
  def hover; end

  # source://capybara//lib/capybara/node/element.rb#373
  def inspect; end

  # Whether or not the element supports multiple results.
  #
  # @return [Boolean] Whether the element supports multiple results.
  #
  # source://capybara//lib/capybara/node/element.rb#318
  def multiple?; end

  # @return [Object] The native element from the driver, this allows access to driver specific methods
  #
  # source://capybara//lib/capybara/node/element.rb#41
  def native; end

  # An XPath expression describing where on the page the element can be found
  #
  # @return [String] An XPath expression
  #
  # source://capybara//lib/capybara/node/element.rb#328
  def path; end

  # Whether or not the element is readonly.
  #
  # @return [Boolean] Whether the element is readonly
  #
  # source://capybara//lib/capybara/node/element.rb#308
  def readonly?; end

  # source://capybara//lib/capybara/node/element.rb#361
  def reload; end

  # Right Click the Element
  #
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#152
  def right_click; end

  # Select this node if is an option element inside a select tag
  #
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#121
  def select_option; end

  # Whether or not the element is selected.
  #
  # @return [Boolean] Whether the element is selected
  #
  # source://capybara//lib/capybara/node/element.rb#288
  def selected?; end

  # Send Keystrokes to the Element
  #
  # Examples:
  #
  #     element.send_keys "foo"                     #=> value: 'foo'
  #     element.send_keys "tet", :left, "s"   #=> value: 'test'
  #     element.send_keys [:control, 'a'], :space   #=> value: ' ' - assuming ctrl-a selects all contents
  #
  # Symbols supported for keys
  # :cancel
  # :help
  # :backspace
  # :tab
  # :clear
  # :return
  # :enter
  # :shift
  # :control
  # :alt
  # :pause
  # :escape
  # :space
  # :page_up
  # :page_down
  # :end
  # :home
  # :left
  # :up
  # :right
  # :down
  # :insert
  # :delete
  # :semicolon
  # :equals
  # :numpad0
  # :numpad1
  # :numpad2
  # :numpad3
  # :numpad4
  # :numpad5
  # :numpad6
  # :numpad7
  # :numpad8
  # :numpad9
  # :multiply      - numeric keypad *
  # :add           - numeric keypad +
  # :separator     - numeric keypad 'separator' key ??
  # :subtract      - numeric keypad -
  # :decimal       - numeric keypad .
  # :divide        - numeric keypad /
  # :f1
  # :f2
  # :f3
  # :f4
  # :f5
  # :f6
  # :f7
  # :f8
  # :f9
  # :f10
  # :f11
  # :f12
  # :meta
  # :command      - alias of :meta
  #
  # @overload send_keys
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#238
  def send_keys(*args); end

  # Set the value of the form element to the given value.
  #
  # @param value [String] The new value
  # @param options [Hash{}] Driver specific options for how to set the value
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#97
  def set(value, options = T.unsafe(nil)); end

  # @return [String] The tag name of the element
  #
  # source://capybara//lib/capybara/node/element.rb#257
  def tag_name; end

  # Retrieve the text of the element. If `Capybara.ignore_hidden_elements`
  # is `true`, which it is by default, then this will return only text
  # which is visible. The exact semantics of this may differ between
  # drivers, but generally any text within elements with `display:none` is
  # ignored. This behaviour can be overridden by passing `:all` to this
  # method.
  #
  # @param type [:all, :visible] Whether to return only visible or all text
  # @return [String] The text of the element
  #
  # source://capybara//lib/capybara/node/element.rb#57
  def text(type = T.unsafe(nil)); end

  # Trigger any event on the current element, for example mouseover or focus
  # events. Does not work in Selenium.
  #
  # @param event [String] The name of the event to trigger
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#340
  def trigger(event); end

  # Unselect this node if is an option element inside a multiple select tag
  #
  # @return [Capybara::Node::Element] The element
  #
  # source://capybara//lib/capybara/node/element.rb#132
  def unselect_option; end

  # @return [String] The value of the form element
  #
  # source://capybara//lib/capybara/node/element.rb#85
  def value; end

  # Whether or not the element is visible. Not all drivers support CSS, so
  # the result may be inaccurate.
  #
  # @return [Boolean] Whether the element is visible
  #
  # source://capybara//lib/capybara/node/element.rb#268
  def visible?; end
end

# source://capybara//lib/capybara/node/finders.rb#4
module Capybara::Node::Finders
  # Find all elements on the page matching the given selector
  # and options.
  #
  # Both XPath and CSS expressions are supported, but Capybara
  # does not try to automatically distinguish between them. The
  # following statements are equivalent:
  #
  #     page.all(:css, 'a#person_123')
  #     page.all(:xpath, './/a[@id="person_123"]')
  #
  #
  # If the type of selector is left out, Capybara uses
  # {Capybara.default_selector}. It's set to :css by default.
  #
  #     page.all("a#person_123")
  #
  #     Capybara.default_selector = :xpath
  #     page.all('.//a[@id="person_123"]')
  #
  # The set of found elements can further be restricted by specifying
  # options. It's possible to select elements by their text or visibility:
  #
  #     page.all('a', text: 'Home')
  #     page.all('#menu li', visible: true)
  #
  # By default if no elements are found, an empty array is returned;
  # however, expectations can be set on the number of elements to be found which
  # will trigger Capybara's waiting behavior for the expectations to match.The
  # expectations can be set using
  #
  #     page.assert_selector('p#foo', count: 4)
  #     page.assert_selector('p#foo', maximum: 10)
  #     page.assert_selector('p#foo', minimum: 1)
  #     page.assert_selector('p#foo', between: 1..10)
  #
  # See {Capybara::Helpers#matches_count?} for additional information about
  # count matching.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @overload all
  # @overload all
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Result] A collection of found elements
  #
  # source://capybara//lib/capybara/node/finders.rb#259
  def all(*args, &optional_filter_block); end

  # Find an {Capybara::Node::Element} based on the given arguments that is also an ancestor of the element called on. +ancestor+ will raise an error if the element
  # is not found.
  #
  # +ancestor+ takes the same options as +find+.
  #
  #     element.ancestor('#foo').find('.bar')
  #     element.ancestor(:xpath, './/div[contains(., "bar")]')
  #     element.ancestor('ul', text: 'Quox').click_link('Delete')
  #
  # If the driver is capable of executing JavaScript, +ancestor+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  # and defaults to 2 seconds.
  #
  # @option options
  # @option options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param options [Hash] a customizable set of options
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ElementNotFound] If the element can't be found before time expires
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#60
  def ancestor(*args, &optional_filter_block); end

  # Find a form field on the page. The field can be found by its name, id or label text.
  #
  # @overload find_field
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#126
  def field_labeled(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Find an {Capybara::Node::Element} based on the given arguments. +find+ will raise an error if the element
  # is not found.
  #
  # If the driver is capable of executing JavaScript, +find+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  # and defaults to 2 seconds.
  # +find+ takes the same options as +all+.
  #
  #     page.find('#foo').find('.bar')
  #     page.find(:xpath, './/div[contains(., "bar")]')
  #     page.find('li', text: 'Quox').click_link('Delete')
  #
  # @option options
  # @option options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param options [Hash] a customizable set of options
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ElementNotFound] If the element can't be found before time expires
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#31
  def find(*args, &optional_filter_block); end

  # Find all elements on the page matching the given selector
  # and options.
  #
  # Both XPath and CSS expressions are supported, but Capybara
  # does not try to automatically distinguish between them. The
  # following statements are equivalent:
  #
  #     page.all(:css, 'a#person_123')
  #     page.all(:xpath, './/a[@id="person_123"]')
  #
  #
  # If the type of selector is left out, Capybara uses
  # {Capybara.default_selector}. It's set to :css by default.
  #
  #     page.all("a#person_123")
  #
  #     Capybara.default_selector = :xpath
  #     page.all('.//a[@id="person_123"]')
  #
  # The set of found elements can further be restricted by specifying
  # options. It's possible to select elements by their text or visibility:
  #
  #     page.all('a', text: 'Home')
  #     page.all('#menu li', visible: true)
  #
  # By default if no elements are found, an empty array is returned;
  # however, expectations can be set on the number of elements to be found which
  # will trigger Capybara's waiting behavior for the expectations to match.The
  # expectations can be set using
  #
  #     page.assert_selector('p#foo', count: 4)
  #     page.assert_selector('p#foo', maximum: 10)
  #     page.assert_selector('p#foo', minimum: 1)
  #     page.assert_selector('p#foo', between: 1..10)
  #
  # See {Capybara::Helpers#matches_count?} for additional information about
  # count matching.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @overload all
  # @overload all
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Result] A collection of found elements
  #
  # source://capybara//lib/capybara/node/finders.rb#259
  def find_all(*args, &optional_filter_block); end

  # Find a button on the page.
  # This can be any \<input> element of type submit, reset, image, button or it can be a
  # \<button> element. All buttons can be found by their id, value, or title. \<button> elements can also be found
  # by their text content, and image \<input> elements by their alt attribute
  #
  # @overload find_button
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#177
  def find_button(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Find a element on the page, given its id.
  #
  # If the driver is capable of executing JavaScript, +find_by_id+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  # and defaults to 2 seconds.
  #
  # @option options
  # @param id [String] id of element
  # @param options [Hash] a customizable set of options
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#192
  def find_by_id(id, options = T.unsafe(nil), &optional_filter_block); end

  # Find a form field on the page. The field can be found by its name, id or label text.
  #
  # @overload find_field
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#126
  def find_field(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Find a link on the page. The link can be found by its id or text.
  #
  # @overload find_link
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#148
  def find_link(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Find the first element on the page matching the given selector
  # and options, or nil if no element matches.  By default no waiting
  # behavior occurs, however if {Capybara.wait_on_first_by_default} is set to true
  # it will trigger Capybara's waiting behavior for a minimum of 1 matching element to be found and
  # return the first.  Waiting behavior can also be triggered by passing in any of the count
  # expectation options.
  #
  # @overload first
  # @return [Capybara::Node::Element] The found element or nil
  #
  # source://capybara//lib/capybara/node/finders.rb#289
  def first(*args, &optional_filter_block); end

  # Find an {Capybara::Node::Element} based on the given arguments that is also a sibling of the element called on. +sibling+ will raise an error if the element
  # is not found.
  #
  #
  # +sibling+ takes the same options as +find+.
  #
  #     element.sibling('#foo').find('.bar')
  #     element.sibling(:xpath, './/div[contains(., "bar")]')
  #     element.sibling('ul', text: 'Quox').click_link('Delete')
  #
  # If the driver is capable of executing JavaScript, +sibling+ will wait for a set amount of time
  # and continuously retry finding the element until either the element is found or the time
  # expires. The length of time +find+ will wait is controlled through {Capybara.default_max_wait_time}
  # and defaults to 2 seconds.
  #
  # @option options
  # @option options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param options [Hash] a customizable set of options
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ElementNotFound] If the element can't be found before time expires
  # @return [Capybara::Node::Element] The found element
  #
  # source://capybara//lib/capybara/node/finders.rb#90
  def sibling(*args, &optional_filter_block); end

  private

  # source://capybara//lib/capybara/node/finders.rb#301
  def synced_resolve(query); end
end

# source://capybara//lib/capybara/node/matchers.rb#4
module Capybara::Node::Matchers
  # source://capybara//lib/capybara/node/matchers.rb#677
  def ==(other); end

  # Asserts that all of the provided selectors are present on the given page
  # or descendants of the current node.  If options are provided, the assertion
  # will check that each locator is present with those options as well (other than :wait).
  #
  #   page.assert_all_of_selectors(:custom, 'Tom', 'Joe', visible: all)
  #   page.assert_all_of_selectors(:css, '#my_div', 'a.not_clicked')
  #
  # It accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as :text and :visible.
  #
  # The :wait option applies to all of the selectors as a group, so all of the locators must be present
  # within :wait (Defaults to Capybara.default_max_wait_time) seconds.
  #
  # @overload assert_all_of_selectors
  #
  # source://capybara//lib/capybara/node/matchers.rb#115
  def assert_all_of_selectors(*args, &optional_filter_block); end

  # Asserts that the current_node matches a given selector
  #
  #     node.assert_matches_selector('p#foo')
  #     node.assert_matches_selector(:xpath, '//p[@id="foo"]')
  #     node.assert_matches_selector(:foo)
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as :text and :visible.
  #
  #     node.assert_matches_selector('li', text: 'Horse', visible: true)
  #
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector does not match
  #
  # source://capybara//lib/capybara/node/matchers.rb#504
  def assert_matches_selector(*args, &optional_filter_block); end

  # Asserts that a given selector is not on the page or a descendant of the current node.
  # Usage is identical to Capybara::Node::Matchers#assert_selector
  #
  # Query options such as :count, :minimum, :maximum, and :between are
  # considered to be an integral part of the selector. This will return
  # true, for example, if a page contains 4 anchors but the query expects 5:
  #
  #     page.assert_no_selector('a', minimum: 1) # Found, raises Capybara::ExpectationNotMet
  #     page.assert_no_selector('a', count: 4)   # Found, raises Capybara::ExpectationNotMet
  #     page.assert_no_selector('a', count: 5)   # Not Found, returns true
  #
  # @raise [Capybara::ExpectationNotMet] If the selector exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#168
  def assert_no_selector(*args, &optional_filter_block); end

  # Asserts that the page or current node doesn't have the given text content,
  # ignoring any HTML tags.
  #
  # @overload assert_no_text
  # @overload assert_no_text
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  #
  # source://capybara//lib/capybara/node/matchers.rb#630
  def assert_no_text(*args); end

  # Asserts that none of the provided selectors are present on the given page
  # or descendants of the current node. If options are provided, the assertion
  # will check that each locator is present with those options as well (other than :wait).
  #
  #   page.assert_none_of_selectors(:custom, 'Tom', 'Joe', visible: all)
  #   page.assert_none_of_selectors(:css, '#my_div', 'a.not_clicked')
  #
  # It accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as :text and :visible.
  #
  # The :wait option applies to all of the selectors as a group, so none of the locators must be present
  # within :wait (Defaults to Capybara.default_max_wait_time) seconds.
  #
  # @overload assert_none_of_selectors
  #
  # source://capybara//lib/capybara/node/matchers.rb#141
  def assert_none_of_selectors(*args, &optional_filter_block); end

  # source://capybara//lib/capybara/node/matchers.rb#510
  def assert_not_matches_selector(*args, &optional_filter_block); end

  # Asserts that a given selector is on the page or a descendant of the current node.
  #
  #     page.assert_selector('p#foo')
  #     page.assert_selector(:xpath, './/p[@id="foo"]')
  #     page.assert_selector(:foo)
  #
  # By default it will check if the expression occurs at least once,
  # but a different number can be specified.
  #
  #     page.assert_selector('p#foo', count: 4)
  #
  # This will check if the expression occurs exactly 4 times. See
  # {Capybara::Node::Finders#all} for other available result size options.
  #
  # If a :count of 0 is specified, it will behave like {#assert_no_selector};
  # however, use of that method is preferred over this one.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as :text and :visible.
  #
  #     page.assert_selector('li', text: 'Horse', visible: true)
  #
  # `assert_selector` can also accept XPath expressions generated by the
  # XPath gem:
  #
  #     page.assert_selector(:xpath, XPath.descendant(:p))
  #
  # @option options
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] If the selector does not exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#92
  def assert_selector(*args, &optional_filter_block); end

  # Asserts that the page or current node has the given text content,
  # ignoring any HTML tags.
  #
  # @overload assert_text
  # @overload assert_text
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  #
  # source://capybara//lib/capybara/node/matchers.rb#614
  def assert_text(*args); end

  # Checks if the page or current node has a button with the given
  # text, value or id.
  #
  # @param locator [String] The text, value or id of a button to check for
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#297
  def has_button?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has a radio button or
  # checkbox with the given label, value or id, that is currently
  # checked.
  #
  # @param locator [String] The label, name or id of a checked field
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#366
  def has_checked_field?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has the given text content,
  # ignoring any HTML tags.
  #
  # Whitespaces are normalized in both node's text and passed text parameter.
  # Note that whitespace isn't normalized in passed regexp as normalizing whitespace
  # in regexp isn't easy and doesn't seem to be worth it.
  #
  # By default it will check if the text occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_text?('lorem ipsum', between: 2..4)
  #
  # This will check if the text occurs from 2 to 4 times.
  #
  # @overload has_text?
  # @overload has_text?
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#656
  def has_content?(*args); end

  # Checks if a given CSS selector is on the page or a descendant of the current node.
  #
  #     page.has_css?('p#foo')
  #
  # By default it will check if the selector occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_css?('p#foo', count: 4)
  #
  # This will check if the selector occurs exactly 4 times.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as :text and :visible.
  #
  #     page.has_css?('li', text: 'Horse', visible: true)
  #
  # @option options
  # @param path [String] A CSS selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean] If the selector exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#245
  def has_css?(path, options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has a form field with the given
  # label, name or id.
  #
  # For text fields and other textual fields, such as textareas and
  # HTML5 email/url/etc. fields, it's possible to specify a :with
  # option to specify the text the field should contain:
  #
  #     page.has_field?('Name', with: 'Jonas')
  #
  # It is also possible to filter by the field type attribute:
  #
  #     page.has_field?('Email', type: 'email')
  #
  # Note: 'textarea' and 'select' are valid type values, matching the associated tag names.
  #
  # @option options
  # @option options
  # @param locator [String] The label, name or id of a field to check for
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#337
  def has_field?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has a link with the given
  # text or id.
  #
  # @option options
  # @param locator [String] The text or id of a link to check for
  # @param options
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#271
  def has_link?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has no button with the given
  # text, value or id.
  #
  # @param locator [String] The text, value or id of a button to check for
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#310
  def has_no_button?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has no radio button or
  # checkbox with the given label, value or id, that is currently
  # checked.
  #
  # @param locator [String] The label, name or id of a checked field
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#380
  def has_no_checked_field?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node does not have the given text
  # content, ignoring any HTML tags and normalizing whitespace.
  #
  # @overload has_no_text?
  # @overload has_no_text?
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#670
  def has_no_content?(*args); end

  # Checks if a given CSS selector is not on the page or a descendant of the current node.
  # Usage is identical to Capybara::Node::Matchers#has_css?
  #
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#257
  def has_no_css?(path, options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has no form field with the given
  # label, name or id. See {Capybara::Node::Matchers#has_field?}.
  #
  # @option options
  # @option options
  # @param locator [String] The label, name or id of a field to check for
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#352
  def has_no_field?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has no link with the given
  # text or id.
  #
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#284
  def has_no_link?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has no select field with the
  # given label, name or id. See {Capybara::Node::Matchers#has_select?}.
  #
  # @param locator [String] The label, name or id of a select box
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#455
  def has_no_select?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if a given selector is not on the page or a descendant of the current node.
  # Usage is identical to Capybara::Node::Matchers#has_selector?
  #
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#53
  def has_no_selector?(*args, &optional_filter_block); end

  # Checks if the page or current node has no table with the given id
  # or caption. See {Capybara::Node::Matchers#has_table?}.
  #
  # @param locator [String] The id or caption of a table
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#483
  def has_no_table?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node does not have the given text
  # content, ignoring any HTML tags and normalizing whitespace.
  #
  # @overload has_no_text?
  # @overload has_no_text?
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#670
  def has_no_text?(*args); end

  # Checks if the page or current node has no radio button or
  # checkbox with the given label, value or id, that is currently
  # unchecked.
  #
  # @param locator [String] The label, name or id of an unchecked field
  # @return [Boolean] Whether it doesn't exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#408
  def has_no_unchecked_field?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if a given XPath expression is not on the page or a descendant of the current node.
  # Usage is identical to Capybara::Node::Matchers#has_xpath?
  #
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#218
  def has_no_xpath?(path, options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has a select field with the
  # given label, name or id.
  #
  # It can be specified which option should currently be selected:
  #
  #     page.has_select?('Language', selected: 'German')
  #
  # For multiple select boxes, several options may be specified:
  #
  #     page.has_select?('Language', selected: ['English', 'German'])
  #
  # It's also possible to check if the exact set of options exists for
  # this select box:
  #
  #     page.has_select?('Language', options: ['English', 'German', 'Spanish'])
  #
  # You can also check for a partial set of options:
  #
  #     page.has_select?('Language', with_options: ['English', 'German'])
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @param locator [String] The label, name or id of a select box
  # @param options [Hash] a customizable set of options
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#442
  def has_select?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if a given selector is on the page or a descendant of the current node.
  #
  #     page.has_selector?('p#foo')
  #     page.has_selector?(:xpath, './/p[@id="foo"]')
  #     page.has_selector?(:foo)
  #
  # By default it will check if the expression occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_selector?('p.foo', count: 4)
  #
  # This will check if the expression occurs exactly 4 times.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as :text and :visible.
  #
  #     page.has_selector?('li', text: 'Horse', visible: true)
  #
  # has_selector? can also accept XPath expressions generated by the
  # XPath gem:
  #
  #     page.has_selector?(:xpath, XPath.descendant(:p))
  #
  # @option args
  # @option args
  # @option args
  # @option args
  # @param args
  # @param kind [Symbol] Optional selector type (:css, :xpath, :field, etc.) - Defaults to Capybara.default_selector
  # @param locator [String] The selector
  # @param options [Hash] a customizable set of options
  # @return [Boolean] If the expression exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#39
  def has_selector?(*args, &optional_filter_block); end

  # Checks if the page or current node has a table with the given id
  # or caption:
  #
  #    page.has_table?('People')
  #
  # @param locator [String] The id or caption of a table
  # @return [Boolean] Whether it exist
  #
  # source://capybara//lib/capybara/node/matchers.rb#470
  def has_table?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the page or current node has the given text content,
  # ignoring any HTML tags.
  #
  # Whitespaces are normalized in both node's text and passed text parameter.
  # Note that whitespace isn't normalized in passed regexp as normalizing whitespace
  # in regexp isn't easy and doesn't seem to be worth it.
  #
  # By default it will check if the text occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_text?('lorem ipsum', between: 2..4)
  #
  # This will check if the text occurs from 2 to 4 times.
  #
  # @overload has_text?
  # @overload has_text?
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#656
  def has_text?(*args); end

  # Checks if the page or current node has a radio button or
  # checkbox with the given label, value or id, that is currently
  # unchecked.
  #
  # @param locator [String] The label, name or id of an unchecked field
  # @return [Boolean] Whether it exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#394
  def has_unchecked_field?(locator = T.unsafe(nil), options = T.unsafe(nil), &optional_filter_block); end

  # Checks if a given XPath expression is on the page or a descendant of the current node.
  #
  #     page.has_xpath?('.//p[@id="foo"]')
  #
  # By default it will check if the expression occurs at least once,
  # but a different number can be specified.
  #
  #     page.has_xpath?('.//p[@id="foo"]', count: 4)
  #
  # This will check if the expression occurs exactly 4 times.
  #
  # It also accepts all options that {Capybara::Node::Finders#all} accepts,
  # such as :text and :visible.
  #
  #     page.has_xpath?('.//li', text: 'Horse', visible: true)
  #
  # has_xpath? can also accept XPath expressions generate by the
  # XPath gem:
  #
  #     xpath = XPath.generate { |x| x.descendant(:p) }
  #     page.has_xpath?(xpath)
  #
  # @option options
  # @param path [String] An XPath expression
  # @param options [Hash] a customizable set of options
  # @return [Boolean] If the expression exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#206
  def has_xpath?(path, options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the current node matches given CSS selector
  #
  # @param css [String] The CSS selector to match against the current code
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#548
  def matches_css?(css, options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the current node matches given selector
  #
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#524
  def matches_selector?(*args, &optional_filter_block); end

  # Checks if the current node matches given XPath expression
  #
  # @param xpath [String, XPath::Expression] The XPath expression to match against the current code
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#537
  def matches_xpath?(xpath, options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the current node does not match given CSS selector
  #
  # @param css [String] The CSS selector to match against the current code
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#584
  def not_matches_css?(css, options = T.unsafe(nil), &optional_filter_block); end

  # Checks if the current node does not match given selector
  # Usage is identical to Capybara::Node::Matchers#has_selector?
  #
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#560
  def not_matches_selector?(*args, &optional_filter_block); end

  # Checks if the current node does not match given XPath expression
  #
  # @param xpath [String, XPath::Expression] The XPath expression to match against the current code
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/node/matchers.rb#573
  def not_matches_xpath?(xpath, options = T.unsafe(nil), &optional_filter_block); end

  # source://capybara//lib/capybara/node/matchers.rb#510
  def refute_matches_selector(*args, &optional_filter_block); end

  # Asserts that a given selector is not on the page or a descendant of the current node.
  # Usage is identical to Capybara::Node::Matchers#assert_selector
  #
  # Query options such as :count, :minimum, :maximum, and :between are
  # considered to be an integral part of the selector. This will return
  # true, for example, if a page contains 4 anchors but the query expects 5:
  #
  #     page.assert_no_selector('a', minimum: 1) # Found, raises Capybara::ExpectationNotMet
  #     page.assert_no_selector('a', count: 4)   # Found, raises Capybara::ExpectationNotMet
  #     page.assert_no_selector('a', count: 5)   # Not Found, returns true
  #
  # @raise [Capybara::ExpectationNotMet] If the selector exists
  #
  # source://capybara//lib/capybara/node/matchers.rb#168
  def refute_selector(*args, &optional_filter_block); end

  private

  # source://capybara//lib/capybara/node/matchers.rb#713
  def _set_query_session_options(query_args); end

  # source://capybara//lib/capybara/node/matchers.rb#693
  def _verify_match_result(query_args, optional_filter_block, &result_block); end

  # source://capybara//lib/capybara/node/matchers.rb#683
  def _verify_selector_result(query_args, optional_filter_block, &result_block); end

  # source://capybara//lib/capybara/node/matchers.rb#703
  def _verify_text(query_args); end
end

# A {Capybara::Node::Simple} is a simpler version of {Capybara::Node::Base} which
# includes only {Capybara::Node::Finders} and {Capybara::Node::Matchers} and does
# not include {Capybara::Node::Actions}. This type of node is returned when
# using {Capybara.string}.
#
# It is useful in that it does not require a session, an application or a driver,
# but can still use Capybara's finders and matchers on any string that contains HTML.
#
# source://capybara//lib/capybara/node/simple.rb#15
class Capybara::Node::Simple
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Matchers
  include ::Capybara::Node::DocumentMatchers

  # @return [Simple] a new instance of Simple
  #
  # source://capybara//lib/capybara/node/simple.rb#22
  def initialize(native); end

  # Retrieve the given attribute
  #
  #     element[:title] # => HTML title attribute
  #
  # @param name [Symbol] The attribute name to retrieve
  # @return [String] The value of the attribute
  #
  # source://capybara//lib/capybara/node/simple.rb#44
  def [](name); end

  # source://capybara//lib/capybara/node/simple.rb#147
  def allow_reload!; end

  # Whether or not the element is checked.
  #
  # @return [Boolean] Whether the element is checked
  #
  # source://capybara//lib/capybara/node/simple.rb#120
  def checked?; end

  # Whether or not the element is disabled.
  #
  # @return [Boolean] Whether the element is disabled
  #
  # source://capybara//lib/capybara/node/simple.rb#129
  def disabled?; end

  # @api private
  #
  # source://capybara//lib/capybara/node/simple.rb#168
  def find_css(css); end

  # @api private
  #
  # source://capybara//lib/capybara/node/simple.rb#173
  def find_xpath(xpath); end

  # source://capybara//lib/capybara/node/simple.rb#163
  def inspect; end

  # Returns the value of attribute native.
  #
  # source://capybara//lib/capybara/node/simple.rb#20
  def native; end

  # An XPath expression describing where on the page the element can be found
  #
  # @return [String] An XPath expression
  #
  # source://capybara//lib/capybara/node/simple.rb#69
  def path; end

  # Whether or not the element is selected.
  #
  # @return [Boolean] Whether the element is selected
  #
  # source://capybara//lib/capybara/node/simple.rb#139
  def selected?; end

  # @api private
  #
  # source://capybara//lib/capybara/node/simple.rb#178
  def session_options; end

  # source://capybara//lib/capybara/node/simple.rb#143
  def synchronize(seconds = T.unsafe(nil)); end

  # @return [String] The tag name of the element
  #
  # source://capybara//lib/capybara/node/simple.rb#59
  def tag_name; end

  # @return [String] The text of the element
  #
  # source://capybara//lib/capybara/node/simple.rb#31
  def text(type = T.unsafe(nil)); end

  # @return [String] The title of the document
  #
  # source://capybara//lib/capybara/node/simple.rb#154
  def title; end

  # @return [String] The value of the form element
  #
  # source://capybara//lib/capybara/node/simple.rb#77
  def value; end

  # Whether or not the element is visible. Does not support CSS, so
  # the result may be inaccurate.
  #
  # @param check_ancestors [Boolean] Whether to inherit visibility from ancestors
  # @return [Boolean] Whether the element is visible
  #
  # source://capybara//lib/capybara/node/simple.rb#102
  def visible?(check_ancestors = T.unsafe(nil)); end
end

# source://capybara//lib/capybara.rb#18
class Capybara::NotSupportedByDriverError < ::Capybara::CapybaraError; end

# @api private
#
# source://capybara//lib/capybara/queries/base_query.rb#4
module Capybara::Queries; end

# source://capybara//lib/capybara/queries/ancestor_query.rb#5
class Capybara::Queries::AncestorQuery < ::Capybara::Queries::MatchQuery
  # source://capybara//lib/capybara/queries/ancestor_query.rb#16
  def description; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/ancestor_query.rb#6
  def resolve_for(node, exact = T.unsafe(nil)); end
end

# @api private
#
# source://capybara//lib/capybara/queries/base_query.rb#5
class Capybara::Queries::BaseQuery
  # @api private
  # @return [BaseQuery] a new instance of BaseQuery
  #
  # source://capybara//lib/capybara/queries/base_query.rb#11
  def initialize(options); end

  # Checks if a count of 0 is valid for the query
  # Returns false if query does not have any count options specified.
  #
  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/base_query.rb#32
  def expects_none?; end

  # Generates a failure message from the query description and count options.
  #
  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#61
  def failure_message; end

  # Checks if the given count matches the query count options.
  # Defaults to true if no count options are specified. If multiple
  # count options exist, it tests that all conditions are met;
  # however, if :count is specified, all other options are ignored.
  #
  # @api private
  # @param count [Integer] The actual number. Should be coercible via Integer()
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/base_query.rb#49
  def matches_count?(count); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#65
  def negative_failure_message; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#8
  def options; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#15
  def session_options; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#9
  def session_options=(_arg0); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#19
  def wait; end

  private

  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#85
  def assert_valid_keys; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/base_query.rb#71
  def count_message; end

  class << self
    # @api private
    #
    # source://capybara//lib/capybara/queries/base_query.rb#23
    def wait(options, default = T.unsafe(nil)); end
  end
end

# @api private
#
# source://capybara//lib/capybara/queries/base_query.rb#6
Capybara::Queries::BaseQuery::COUNT_KEYS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://capybara//lib/capybara/queries/current_path_query.rb#7
class Capybara::Queries::CurrentPathQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @return [CurrentPathQuery] a new instance of CurrentPathQuery
  #
  # source://capybara//lib/capybara/queries/current_path_query.rb#8
  def initialize(expected_path, options = T.unsafe(nil)); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/current_path_query.rb#40
  def failure_message; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/current_path_query.rb#44
  def negative_failure_message; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/current_path_query.rb#20
  def resolves_for?(session); end

  private

  # @api private
  #
  # source://capybara//lib/capybara/queries/current_path_query.rb#59
  def assert_valid_keys; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/current_path_query.rb#50
  def failure_message_helper(negated = T.unsafe(nil)); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/current_path_query.rb#55
  def valid_keys; end
end

# @api private
#
# source://capybara//lib/capybara/queries/match_query.rb#3
class Capybara::Queries::MatchQuery < ::Capybara::Queries::SelectorQuery
  # @api private
  #
  # source://capybara//lib/capybara/queries/match_query.rb#4
  def visible; end

  private

  # @api private
  #
  # source://capybara//lib/capybara/queries/match_query.rb#14
  def valid_keys; end
end

# @api private
#
# source://capybara//lib/capybara/queries/selector_query.rb#4
class Capybara::Queries::SelectorQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @return [SelectorQuery] a new instance of SelectorQuery
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#10
  def initialize(*args, &filter_block); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#138
  def css; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#45
  def description; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#118
  def exact?; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def expression; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def expression=(_arg0); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def find; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def find=(_arg0); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#43
  def label; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def locator; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def locator=(_arg0); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#123
  def match; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#60
  def matches_filters?(node); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#42
  def name; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def negative; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def negative=(_arg0); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def options; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def options=(_arg0); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#143
  def resolve_for(node, exact = T.unsafe(nil)); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def selector; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#5
  def selector=(_arg0); end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#162
  def supports_exact?; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#110
  def visible; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#127
  def xpath(exact = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#223
  def apply_expression_filters(expr); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#190
  def assert_valid_keys; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#186
  def custom_keys; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#245
  def describe_within?; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#241
  def exact_text; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#180
  def expression_filters; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#211
  def filtered_css(expr); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#197
  def filtered_xpath(expr); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#172
  def node_filters; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#168
  def valid_keys; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/selector_query.rb#235
  def warn_exact_usage; end
end

# @api private
#
# source://capybara//lib/capybara/queries/selector_query.rb#7
Capybara::Queries::SelectorQuery::VALID_KEYS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://capybara//lib/capybara/queries/selector_query.rb#8
Capybara::Queries::SelectorQuery::VALID_MATCH = T.let(T.unsafe(nil), Array)

# @api private
#
# source://capybara//lib/capybara/queries/sibling_query.rb#5
class Capybara::Queries::SiblingQuery < ::Capybara::Queries::MatchQuery
  # @api private
  #
  # source://capybara//lib/capybara/queries/sibling_query.rb#16
  def description; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/sibling_query.rb#6
  def resolve_for(node, exact = T.unsafe(nil)); end
end

# @api private
#
# source://capybara//lib/capybara/queries/text_query.rb#5
class Capybara::Queries::TextQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @return [TextQuery] a new instance of TextQuery
  #
  # source://capybara//lib/capybara/queries/text_query.rb#6
  def initialize(*args); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/text_query.rb#37
  def description; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/text_query.rb#29
  def failure_message; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/text_query.rb#33
  def negative_failure_message; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/text_query.rb#23
  def resolve_for(node); end

  private

  # @api private
  #
  # source://capybara//lib/capybara/queries/text_query.rb#51
  def build_message(report_on_invisible); end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/text_query.rb#89
  def check_visible_text?; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/text_query.rb#47
  def exact?; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/text_query.rb#93
  def text(node, query_type); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/text_query.rb#85
  def valid_keys; end
end

# @api private
#
# source://capybara//lib/capybara/queries/title_query.rb#5
class Capybara::Queries::TitleQuery < ::Capybara::Queries::BaseQuery
  # @api private
  # @return [TitleQuery] a new instance of TitleQuery
  #
  # source://capybara//lib/capybara/queries/title_query.rb#6
  def initialize(expected_title, options = T.unsafe(nil)); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/title_query.rb#22
  def failure_message; end

  # @api private
  #
  # source://capybara//lib/capybara/queries/title_query.rb#26
  def negative_failure_message; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/queries/title_query.rb#17
  def resolves_for?(node); end

  private

  # @api private
  #
  # source://capybara//lib/capybara/queries/title_query.rb#32
  def failure_message_helper(negated = T.unsafe(nil)); end

  # @api private
  #
  # source://capybara//lib/capybara/queries/title_query.rb#37
  def valid_keys; end
end

# @deprecated This class and its methods are not supposed to be used by users of Capybara's public API.
#   It may be removed in future versions of Capybara.
#
# source://capybara//lib/capybara/query.rb#6
Capybara::Query = Capybara::Queries::SelectorQuery

# source://capybara//lib/capybara.rb#399
module Capybara::RackTest; end

# source://capybara//lib/capybara/rack_test/browser.rb#2
class Capybara::RackTest::Browser
  include ::Rack::Test::Methods

  # @return [Browser] a new instance of Browser
  #
  # source://capybara//lib/capybara/rack_test/browser.rb#8
  def initialize(driver); end

  # source://capybara//lib/capybara/rack_test/browser.rb#12
  def app; end

  # Returns the value of attribute current_host.
  #
  # source://capybara//lib/capybara/rack_test/browser.rb#6
  def current_host; end

  # Sets the attribute current_host
  #
  # @param value the value to set the attribute current_host to.
  #
  # source://capybara//lib/capybara/rack_test/browser.rb#6
  def current_host=(_arg0); end

  # source://capybara//lib/capybara/rack_test/browser.rb#72
  def current_url; end

  # source://capybara//lib/capybara/rack_test/browser.rb#89
  def dom; end

  # Returns the value of attribute driver.
  #
  # source://capybara//lib/capybara/rack_test/browser.rb#5
  def driver; end

  # source://capybara//lib/capybara/rack_test/browser.rb#93
  def find(format, selector); end

  # source://capybara//lib/capybara/rack_test/browser.rb#35
  def follow(method, path, attributes = T.unsafe(nil)); end

  # source://capybara//lib/capybara/rack_test/browser.rb#101
  def html; end

  # source://capybara//lib/capybara/rack_test/browser.rb#16
  def options; end

  # source://capybara//lib/capybara/rack_test/browser.rb#50
  def process(method, path, attributes = T.unsafe(nil), env = T.unsafe(nil)); end

  # source://capybara//lib/capybara/rack_test/browser.rb#40
  def process_and_follow_redirects(method, path, attributes = T.unsafe(nil), env = T.unsafe(nil)); end

  # source://capybara//lib/capybara/rack_test/browser.rb#25
  def refresh; end

  # source://capybara//lib/capybara/rack_test/browser.rb#85
  def reset_cache!; end

  # source://capybara//lib/capybara/rack_test/browser.rb#78
  def reset_host!; end

  # source://capybara//lib/capybara/rack_test/browser.rb#30
  def submit(method, path, attributes); end

  # source://capybara//lib/capybara/rack_test/browser.rb#107
  def title; end

  # source://capybara//lib/capybara/rack_test/browser.rb#20
  def visit(path, attributes = T.unsafe(nil)); end

  protected

  # source://capybara//lib/capybara/rack_test/browser.rb#118
  def build_rack_mock_session; end

  # source://capybara//lib/capybara/rack_test/browser.rb#123
  def request_path; end
end

# source://capybara//lib/capybara/rack_test/css_handlers.rb#2
class Capybara::RackTest::CSSHandlers < ::BasicObject
  include ::Kernel

  # source://capybara//lib/capybara/rack_test/css_handlers.rb#5
  def disabled(list); end

  # source://capybara//lib/capybara/rack_test/css_handlers.rb#8
  def enabled(list); end
end

# source://capybara//lib/capybara/rack_test/driver.rb#8
class Capybara::RackTest::Driver < ::Capybara::Driver::Base
  # @raise [ArgumentError]
  # @return [Driver] a new instance of Driver
  #
  # source://capybara//lib/capybara/rack_test/driver.rb#16
  def initialize(app, options = T.unsafe(nil)); end

  # Returns the value of attribute app.
  #
  # source://capybara//lib/capybara/rack_test/driver.rb#14
  def app; end

  # source://capybara//lib/capybara/rack_test/driver.rb#23
  def browser; end

  # @deprecated This method is being removed
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/driver.rb#96
  def browser_initialized?; end

  # source://capybara//lib/capybara/rack_test/driver.rb#59
  def current_url; end

  # source://capybara//lib/capybara/rack_test/driver.rb#103
  def delete(*args, &block); end

  # source://capybara//lib/capybara/rack_test/driver.rb#83
  def dom; end

  # source://capybara//lib/capybara/rack_test/driver.rb#75
  def find_css(selector); end

  # source://capybara//lib/capybara/rack_test/driver.rb#71
  def find_xpath(selector); end

  # source://capybara//lib/capybara/rack_test/driver.rb#55
  def follow(method, path, attributes = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/driver.rb#27
  def follow_redirects?; end

  # source://capybara//lib/capybara/rack_test/driver.rb#100
  def get(*args, &block); end

  # source://capybara//lib/capybara/rack_test/driver.rb#104
  def header(key, value); end

  # source://capybara//lib/capybara/rack_test/driver.rb#79
  def html; end

  # Returns the value of attribute options.
  #
  # source://capybara//lib/capybara/rack_test/driver.rb#14
  def options; end

  # source://capybara//lib/capybara/rack_test/driver.rb#101
  def post(*args, &block); end

  # source://capybara//lib/capybara/rack_test/driver.rb#102
  def put(*args, &block); end

  # source://capybara//lib/capybara/rack_test/driver.rb#31
  def redirect_limit; end

  # source://capybara//lib/capybara/rack_test/driver.rb#47
  def refresh; end

  # source://capybara//lib/capybara/rack_test/driver.rb#39
  def request; end

  # source://capybara//lib/capybara/rack_test/driver.rb#91
  def reset!; end

  # source://capybara//lib/capybara/rack_test/driver.rb#35
  def response; end

  # source://capybara//lib/capybara/rack_test/driver.rb#63
  def response_headers; end

  # source://capybara//lib/capybara/rack_test/driver.rb#67
  def status_code; end

  # source://capybara//lib/capybara/rack_test/driver.rb#51
  def submit(method, path, attributes); end

  # source://capybara//lib/capybara/rack_test/driver.rb#87
  def title; end

  # source://capybara//lib/capybara/rack_test/driver.rb#43
  def visit(path, attributes = T.unsafe(nil)); end
end

# source://capybara//lib/capybara/rack_test/driver.rb#9
Capybara::RackTest::Driver::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://capybara//lib/capybara/rack_test/form.rb#6
class Capybara::RackTest::Form < ::Capybara::RackTest::Node
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/form.rb#83
  def multipart?; end

  # source://capybara//lib/capybara/rack_test/form.rb#20
  def params(button); end

  # source://capybara//lib/capybara/rack_test/form.rb#77
  def submit(button); end

  private

  # source://capybara//lib/capybara/rack_test/form.rb#107
  def make_params; end

  # source://capybara//lib/capybara/rack_test/form.rb#99
  def merge_param!(params, key, value); end

  # source://capybara//lib/capybara/rack_test/form.rb#95
  def request_method; end
end

# This only needs to inherit from Rack::Test::UploadedFile because Rack::Test checks for
# the class specifically when determining whether to construct the request as multipart.
# That check should be based solely on the form element's 'enctype' attribute value,
# which should probably be provided to Rack::Test in its non-GET request methods.
#
# source://capybara//lib/capybara/rack_test/form.rb#7
class Capybara::RackTest::Form::NilUploadedFile < ::Rack::Test::UploadedFile
  # @return [NilUploadedFile] a new instance of NilUploadedFile
  #
  # source://capybara//lib/capybara/rack_test/form.rb#8
  def initialize; end

  # source://capybara//lib/capybara/rack_test/form.rb#14
  def content_type; end

  # source://capybara//lib/capybara/rack_test/form.rb#13
  def original_filename; end

  # source://capybara//lib/capybara/rack_test/form.rb#15
  def path; end

  # source://capybara//lib/capybara/rack_test/form.rb#17
  def read; end

  # source://capybara//lib/capybara/rack_test/form.rb#16
  def size; end
end

# source://capybara//lib/capybara/rack_test/form.rb#89
class Capybara::RackTest::Form::ParamsHash < ::Hash
  # source://capybara//lib/capybara/rack_test/form.rb#90
  def to_params_hash; end
end

# source://capybara//lib/capybara/rack_test/node.rb#2
class Capybara::RackTest::Node < ::Capybara::Driver::Node
  # source://capybara//lib/capybara/rack_test/node.rb#116
  def ==(other); end

  # source://capybara//lib/capybara/rack_test/node.rb#11
  def [](name); end

  # source://capybara//lib/capybara/rack_test/node.rb#3
  def all_text; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#88
  def checked?; end

  # source://capybara//lib/capybara/rack_test/node.rb#56
  def click; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#96
  def disabled?; end

  # source://capybara//lib/capybara/rack_test/node.rb#112
  def find_css(locator); end

  # source://capybara//lib/capybara/rack_test/node.rb#108
  def find_xpath(locator); end

  # source://capybara//lib/capybara/rack_test/node.rb#104
  def path; end

  # source://capybara//lib/capybara/rack_test/node.rb#41
  def select_option; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#92
  def selected?; end

  # source://capybara//lib/capybara/rack_test/node.rb#19
  def set(value); end

  # source://capybara//lib/capybara/rack_test/node.rb#80
  def tag_name; end

  # source://capybara//lib/capybara/rack_test/node.rb#49
  def unselect_option; end

  # source://capybara//lib/capybara/rack_test/node.rb#15
  def value; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#84
  def visible?; end

  # source://capybara//lib/capybara/rack_test/node.rb#7
  def visible_text; end

  protected

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#202
  def checkbox?; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#206
  def input_field?; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#210
  def radio?; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#218
  def text_or_password?; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#214
  def textarea?; end

  # source://capybara//lib/capybara/rack_test/node.rb#122
  def unnormalized_text(check_ancestor_visibility = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/rack_test/node.rb#196
  def attribute_is_not_blank?(attribute); end

  # source://capybara//lib/capybara/rack_test/node.rb#151
  def form; end

  # a reference to the select node if this is an option node
  #
  # source://capybara//lib/capybara/rack_test/node.rb#143
  def select_node; end

  # source://capybara//lib/capybara/rack_test/node.rb#165
  def set_checkbox(value); end

  # source://capybara//lib/capybara/rack_test/node.rb#173
  def set_input(value); end

  # source://capybara//lib/capybara/rack_test/node.rb#159
  def set_radio(_value); end

  # source://capybara//lib/capybara/rack_test/node.rb#138
  def string_node; end

  # source://capybara//lib/capybara/rack_test/node.rb#147
  def type; end
end

# source://capybara//lib/capybara.rb#22
class Capybara::ReadOnlyElementError < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara/session/config.rb#107
class Capybara::ReadOnlySessionConfig < ::SimpleDelegator
  # source://capybara//lib/capybara/session/config.rb#109
  def always_include_port=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def app_host=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def asset_host=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def automatic_label_click=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def automatic_reload=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def default_host=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def default_max_wait_time=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def default_selector=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def enable_aria_label=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def exact=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def exact_options=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def exact_text=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def ignore_hidden_elements=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def match=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def raise_server_errors=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def run_server=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def save_and_open_page_path=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def save_path=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def server_errors=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def server_host=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def server_port=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def visible_text_only=(val); end

  # source://capybara//lib/capybara/session/config.rb#109
  def wait_on_first_by_default=(val); end
end

# A {Capybara::Result} represents a collection of {Capybara::Node::Element} on the page. It is possible to interact with this
# collection similar to an Array because it implements Enumerable and offers the following Array methods through delegation:
#
# * []
# * each()
# * at()
# * size()
# * count()
# * length()
# * first()
# * last()
# * empty?()
#
# @see Capybara::Node::Element
#
# source://capybara//lib/capybara/result.rb#22
class Capybara::Result
  include ::Enumerable
  extend ::Forwardable

  # @return [Result] a new instance of Result
  #
  # source://capybara//lib/capybara/result.rb#26
  def initialize(elements, query); end

  # source://capybara//lib/capybara/result.rb#49
  def [](*args); end

  # source://capybara//lib/capybara/result.rb#49
  def at(*args); end

  # source://capybara//lib/capybara/result.rb#37
  def each(&block); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/result.rb#61
  def empty?; end

  # source://capybara//lib/capybara/result.rb#106
  def failure_message; end

  def index(*_arg0); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def inspect(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def last(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def length(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/result.rb#65
  def matches_count?; end

  # source://capybara//lib/capybara/result.rb#120
  def negative_failure_message; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def sample(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def size(*args, **_arg1, &block); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def values_at(*args, **_arg1, &block); end

  private

  # source://capybara//lib/capybara/result.rb#126
  def full_results; end

  # source://capybara//lib/capybara/result.rb#135
  def lazy_select_elements(&block); end

  # source://capybara//lib/capybara/result.rb#131
  def rest; end
end

# source://capybara//lib/capybara.rb#20
class Capybara::ScopeError < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara/selector/filters/base.rb#3
class Capybara::Selector
  # @return [Selector] a new instance of Selector
  #
  # source://capybara//lib/capybara/selector/selector.rb#44
  def initialize(name, &block); end

  # source://capybara//lib/capybara/selector/selector.rb#153
  def call(locator, options = T.unsafe(nil)); end

  # Define a selector by a CSS selector
  #
  # @overload css
  # @overload css
  # @return [#call] The block that will be called to generate the CSS selector
  #
  # source://capybara//lib/capybara/selector/selector.rb#106
  def css(*expression_filters, &block); end

  # source://capybara//lib/capybara/selector/selector.rb#58
  def custom_filters; end

  # source://capybara//lib/capybara/selector/selector.rb#225
  def default_visibility(fallback = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selector/selector.rb#208
  def describe(&block); end

  # Description of the selector
  #
  # @param options [Hash] The options of the query used to generate the description
  # @return [String] Description of the selector when used with the options passed
  #
  # source://capybara//lib/capybara/selector/selector.rb#149
  def description(options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selector/selector.rb#193
  def expression_filter(name, *types_and_options, &block); end

  # source://capybara//lib/capybara/selector/selector.rb#66
  def expression_filters; end

  # Define a non-expression filter for use with this selector
  #
  # @overload filter
  #
  # source://capybara//lib/capybara/selector/selector.rb#187
  def filter(name, *types_and_options, &block); end

  # source://capybara//lib/capybara/selector/selector.rb#199
  def filter_set(name, filters_to_use = T.unsafe(nil)); end

  # Returns the value of attribute format.
  #
  # source://capybara//lib/capybara/selector/selector.rb#24
  def format; end

  # Set/get a descriptive label for the selector
  #
  # @overload label
  # @overload label
  # @return [String] The currently set label
  #
  # source://capybara//lib/capybara/selector/selector.rb#137
  def label(label = T.unsafe(nil)); end

  # Automatic selector detection
  #
  # @return [#call] The block that will be used to detect selector match
  # @yield [locator] This block takes the passed in locator string and returns whether or not it matches the selector
  # @yieldparam , [String] locator      The locator string used to determin if it matches the selector
  # @yieldreturn [Boolean] Whether this selector matches the locator string
  #
  # source://capybara//lib/capybara/selector/selector.rb#123
  def match(&block); end

  # Should this selector be used for the passed in locator
  #
  #  This is used by the automatic selector selection mechanism when no selector type is passed to a selector query
  #
  # @param locator [String] The locator passed to the query
  # @return [Boolean] Whether or not to use this selector
  #
  # source://capybara//lib/capybara/selector/selector.rb#171
  def match?(locator); end

  # Returns the value of attribute name.
  #
  # source://capybara//lib/capybara/selector/selector.rb#24
  def name; end

  # source://capybara//lib/capybara/selector/selector.rb#62
  def node_filters; end

  # Set the default visibility mode that shouble be used if no visibile option is passed when using the selector.
  # If not specified will default to the behavior indicated by Capybara.ignore_hidden_elements
  #
  # @param default_visibility [Symbol] Only find elements with the specified visibility:
  #   * :all - finds visible and invisible elements.
  #   * :hidden - only finds invisible elements.
  #   * :visible - only finds visible elements.
  #
  # source://capybara//lib/capybara/selector/selector.rb#221
  def visible(default_visibility); end

  # Define a selector by an xpath expression
  #
  # @overload xpath
  # @overload xpath
  # @return [#call] The block that will be called to generate the XPath expression
  #
  # source://capybara//lib/capybara/selector/selector.rb#84
  def xpath(*expression_filters, &block); end

  private

  # source://capybara//lib/capybara/selector/selector.rb#253
  def describe_all_expression_filters(opts = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selector/selector.rb#257
  def find_by_attr(attribute, value); end

  # source://capybara//lib/capybara/selector/selector.rb#266
  def find_by_class_attr(classes); end

  # source://capybara//lib/capybara/selector/selector.rb#235
  def locate_field(xpath, locator, options = T.unsafe(nil)); end

  class << self
    # source://capybara//lib/capybara/selector/selector.rb#31
    def add(name, &block); end

    # source://capybara//lib/capybara/selector/selector.rb#27
    def all; end

    # source://capybara//lib/capybara/selector/filter.rb#7
    def const_missing(const_name); end

    # source://capybara//lib/capybara/selector/selector.rb#39
    def remove(name); end

    # source://capybara//lib/capybara/selector/selector.rb#35
    def update(name, &block); end
  end
end

# source://capybara//lib/capybara/selector/css.rb#3
class Capybara::Selector::CSS
  class << self
    # source://capybara//lib/capybara/selector/css.rb#4
    def escape(str); end

    # source://capybara//lib/capybara/selector/css.rb#17
    def escape_char(c); end
  end
end

# source://capybara//lib/capybara/selector/css.rb#26
Capybara::Selector::CSS::ESCAPE = T.let(T.unsafe(nil), Regexp)

# source://capybara//lib/capybara/selector/css.rb#23
Capybara::Selector::CSS::H = T.let(T.unsafe(nil), Regexp)

# source://capybara//lib/capybara/selector/css.rb#27
Capybara::Selector::CSS::NMSTART = T.let(T.unsafe(nil), Regexp)

# source://capybara//lib/capybara/selector/css.rb#25
Capybara::Selector::CSS::NONASCII = T.let(T.unsafe(nil), Regexp)

# source://capybara//lib/capybara/selector/css.rb#22
Capybara::Selector::CSS::S = T.let(T.unsafe(nil), String)

# source://capybara//lib/capybara/selector/css.rb#24
Capybara::Selector::CSS::UNICODE = T.let(T.unsafe(nil), Regexp)

# source://capybara//lib/capybara/selector/filter_set.rb#6
class Capybara::Selector::FilterSet
  # @return [FilterSet] a new instance of FilterSet
  #
  # source://capybara//lib/capybara/selector/filter_set.rb#9
  def initialize(name, &block); end

  # source://capybara//lib/capybara/selector/filter_set.rb#23
  def describe(&block); end

  # source://capybara//lib/capybara/selector/filter_set.rb#27
  def description(options = T.unsafe(nil)); end

  # Returns the value of attribute descriptions.
  #
  # source://capybara//lib/capybara/selector/filter_set.rb#7
  def descriptions; end

  # source://capybara//lib/capybara/selector/filter_set.rb#19
  def expression_filter(name, *types_and_options, &block); end

  # source://capybara//lib/capybara/selector/filter_set.rb#46
  def expression_filters; end

  # source://capybara//lib/capybara/selector/filter_set.rb#15
  def filter(name, *types_and_options, &block); end

  # source://capybara//lib/capybara/selector/filter_set.rb#38
  def filters; end

  # source://capybara//lib/capybara/selector/filter_set.rb#42
  def node_filters; end

  private

  # source://capybara//lib/capybara/selector/filter_set.rb#67
  def add_filter(name, filter_class, *types_and_options, &block); end

  class << self
    # source://capybara//lib/capybara/selector/filter_set.rb#56
    def add(name, &block); end

    # source://capybara//lib/capybara/selector/filter_set.rb#52
    def all; end

    # source://capybara//lib/capybara/selector/filter_set.rb#60
    def remove(name); end
  end
end

# source://capybara//lib/capybara/selector/filters/base.rb#4
module Capybara::Selector::Filters; end

# source://capybara//lib/capybara/selector/filters/base.rb#5
class Capybara::Selector::Filters::Base
  # @return [Base] a new instance of Base
  #
  # source://capybara//lib/capybara/selector/filters/base.rb#6
  def initialize(name, block, options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selector/filters/base.rb#17
  def default; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selector/filters/base.rb#13
  def default?; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selector/filters/base.rb#21
  def skip?(value); end

  private

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selector/filters/base.rb#27
  def valid_value?(value); end
end

# source://capybara//lib/capybara/selector/filters/expression_filter.rb#7
class Capybara::Selector::Filters::ExpressionFilter < ::Capybara::Selector::Filters::Base
  # source://capybara//lib/capybara/selector/filters/expression_filter.rb#8
  def apply_filter(expr, value); end
end

# source://capybara//lib/capybara/selector/filters/expression_filter.rb#26
class Capybara::Selector::Filters::IdentityExpressionFilter < ::Capybara::Selector::Filters::ExpressionFilter
  # @return [IdentityExpressionFilter] a new instance of IdentityExpressionFilter
  #
  # source://capybara//lib/capybara/selector/filters/expression_filter.rb#27
  def initialize; end

  # source://capybara//lib/capybara/selector/filters/expression_filter.rb#34
  def apply_filter(expr, _value); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selector/filters/expression_filter.rb#30
  def default?; end
end

# source://capybara//lib/capybara/selector/filters/node_filter.rb#7
class Capybara::Selector::Filters::NodeFilter < ::Capybara::Selector::Filters::Base
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selector/filters/node_filter.rb#8
  def matches?(node, value); end
end

# source://capybara//lib/capybara.rb#400
module Capybara::Selenium; end

# source://capybara//lib/capybara/selenium/driver.rb#4
class Capybara::Selenium::Driver < ::Capybara::Driver::Base
  # @return [Driver] a new instance of Driver
  #
  # source://capybara//lib/capybara/selenium/driver.rb#38
  def initialize(app, options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selenium/driver.rb#234
  def accept_modal(_type, options = T.unsafe(nil)); end

  # Returns the value of attribute app.
  #
  # source://capybara//lib/capybara/selenium/driver.rb#13
  def app; end

  # source://capybara//lib/capybara/selenium/driver.rb#15
  def browser; end

  # @deprecated This method is being removed
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#298
  def browser_initialized?; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#293
  def chrome?; end

  # source://capybara//lib/capybara/selenium/driver.rb#211
  def close_window(handle); end

  # source://capybara//lib/capybara/selenium/driver.rb#75
  def current_url; end

  # source://capybara//lib/capybara/selenium/driver.rb#182
  def current_window_handle; end

  # source://capybara//lib/capybara/selenium/driver.rb#245
  def dismiss_modal(_type, options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selenium/driver.rb#99
  def evaluate_async_script(script, *args); end

  # source://capybara//lib/capybara/selenium/driver.rb#94
  def evaluate_script(script, *args); end

  # source://capybara//lib/capybara/selenium/driver.rb#90
  def execute_script(script, *args); end

  # source://capybara//lib/capybara/selenium/driver.rb#83
  def find_css(selector); end

  # source://capybara//lib/capybara/selenium/driver.rb#79
  def find_xpath(selector); end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#288
  def firefox?; end

  # source://capybara//lib/capybara/selenium/driver.rb#59
  def go_back; end

  # source://capybara//lib/capybara/selenium/driver.rb#63
  def go_forward; end

  # source://capybara//lib/capybara/selenium/driver.rb#67
  def html; end

  # source://capybara//lib/capybara/selenium/driver.rb#266
  def invalid_element_errors; end

  # @api private
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#283
  def marionette?; end

  # source://capybara//lib/capybara/selenium/driver.rb#204
  def maximize_window(handle); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#88
  def needs_server?; end

  # source://capybara//lib/capybara/selenium/driver.rb#278
  def no_such_window_error; end

  # source://capybara//lib/capybara/selenium/driver.rb#221
  def open_new_window; end

  # Returns the value of attribute options.
  #
  # source://capybara//lib/capybara/selenium/driver.rb#13
  def options; end

  # source://capybara//lib/capybara/selenium/driver.rb#253
  def quit; end

  # source://capybara//lib/capybara/selenium/driver.rb#52
  def refresh; end

  # source://capybara//lib/capybara/selenium/driver.rb#109
  def reset!; end

  # source://capybara//lib/capybara/selenium/driver.rb#193
  def resize_window_to(handle, width, height); end

  # source://capybara//lib/capybara/selenium/driver.rb#105
  def save_screenshot(path, _options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selenium/driver.rb#164
  def switch_to_frame(frame); end

  # source://capybara//lib/capybara/selenium/driver.rb#225
  def switch_to_window(handle); end

  # source://capybara//lib/capybara/selenium/driver.rb#71
  def title; end

  # source://capybara//lib/capybara/selenium/driver.rb#48
  def visit(path); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#87
  def wait?; end

  # source://capybara//lib/capybara/selenium/driver.rb#217
  def window_handles; end

  # source://capybara//lib/capybara/selenium/driver.rb#186
  def window_size(handle); end

  # source://capybara//lib/capybara/selenium/driver.rb#229
  def within_window(locator); end

  private

  # @api private
  #
  # source://capybara//lib/capybara/selenium/driver.rb#305
  def browser_name; end

  # source://capybara//lib/capybara/selenium/driver.rb#417
  def find_headless_modal(options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selenium/driver.rb#400
  def find_modal(options = T.unsafe(nil)); end

  # @raise [Capybara::ElementNotFound]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#317
  def find_window(locator); end

  # source://capybara//lib/capybara/selenium/driver.rb#334
  def insert_modal_handlers(accept, response_text); end

  # source://capybara//lib/capybara/selenium/driver.rb#468
  def load_selenium; end

  # source://capybara//lib/capybara/selenium/driver.rb#309
  def modal_error; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/driver.rb#447
  def silenced_unknown_error_message?(msg); end

  # source://capybara//lib/capybara/selenium/driver.rb#451
  def silenced_unknown_error_messages; end

  # source://capybara//lib/capybara/selenium/driver.rb#455
  def unwrap_script_result(arg); end

  # source://capybara//lib/capybara/selenium/driver.rb#388
  def within_given_window(handle); end
end

# source://capybara//lib/capybara/selenium/driver.rb#6
Capybara::Selenium::Driver::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://capybara//lib/capybara/selenium/driver.rb#11
Capybara::Selenium::Driver::SPECIAL_OPTIONS = T.let(T.unsafe(nil), Array)

# source://capybara//lib/capybara/selenium/node.rb#2
class Capybara::Selenium::Node < ::Capybara::Driver::Node
  # source://capybara//lib/capybara/selenium/node.rb#193
  def ==(other); end

  # source://capybara//lib/capybara/selenium/node.rb#14
  def [](name); end

  # source://capybara//lib/capybara/selenium/node.rb#9
  def all_text; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/node.rb#152
  def checked?; end

  # source://capybara//lib/capybara/selenium/node.rb#102
  def click; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/node.rb#181
  def content_editable?; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/node.rb#158
  def disabled?; end

  # source://capybara//lib/capybara/selenium/node.rb#121
  def double_click; end

  # source://capybara//lib/capybara/selenium/node.rb#137
  def drag_to(element); end

  # source://capybara//lib/capybara/selenium/node.rb#189
  def find_css(locator); end

  # source://capybara//lib/capybara/selenium/node.rb#185
  def find_xpath(locator); end

  # source://capybara//lib/capybara/selenium/node.rb#131
  def hover; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/node.rb#176
  def multiple?; end

  # source://capybara//lib/capybara/selenium/node.rb#197
  def path; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/node.rb#171
  def readonly?; end

  # source://capybara//lib/capybara/selenium/node.rb#115
  def right_click; end

  # source://capybara//lib/capybara/selenium/node.rb#93
  def select_option; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/node.rb#152
  def selected?; end

  # source://capybara//lib/capybara/selenium/node.rb#127
  def send_keys(*args); end

  # Set the value of the form element to the given value.
  #
  # @option options
  # @param value [String] The new value
  # @param options [Hash{}] Driver specific options for how to set the value
  #
  # source://capybara//lib/capybara/selenium/node.rb#39
  def set(value, options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/selenium/node.rb#143
  def tag_name; end

  # @raise [Capybara::UnselectNotAllowed]
  #
  # source://capybara//lib/capybara/selenium/node.rb#97
  def unselect_option; end

  # source://capybara//lib/capybara/selenium/node.rb#20
  def value; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/selenium/node.rb#147
  def visible?; end

  # source://capybara//lib/capybara/selenium/node.rb#4
  def visible_text; end

  private

  # source://capybara//lib/capybara/selenium/node.rb#251
  def scroll_if_needed(&block); end

  # a reference to the select node if this is an option node
  #
  # source://capybara//lib/capybara/selenium/node.rb#223
  def select_node; end

  # source://capybara//lib/capybara/selenium/node.rb#227
  def set_text(value, options); end
end

# source://capybara//lib/capybara/server.rb#7
class Capybara::Server
  # @return [Server] a new instance of Server
  #
  # source://capybara//lib/capybara/server.rb#63
  def initialize(app, port = T.unsafe(nil), host = T.unsafe(nil), server_errors = T.unsafe(nil)); end

  # Returns the value of attribute app.
  #
  # source://capybara//lib/capybara/server.rb#61
  def app; end

  # source://capybara//lib/capybara/server.rb#97
  def boot; end

  # source://capybara//lib/capybara/server.rb#75
  def error; end

  # Returns the value of attribute host.
  #
  # source://capybara//lib/capybara/server.rb#61
  def host; end

  # Returns the value of attribute port.
  #
  # source://capybara//lib/capybara/server.rb#61
  def port; end

  # source://capybara//lib/capybara/server.rb#71
  def reset_error!; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/server.rb#79
  def responsive?; end

  # source://capybara//lib/capybara/server.rb#91
  def wait_for_pending_requests; end

  private

  # source://capybara//lib/capybara/server.rb#127
  def find_available_port(host); end

  # source://capybara//lib/capybara/server.rb#115
  def middleware; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/server.rb#123
  def pending_requests?; end

  # source://capybara//lib/capybara/server.rb#119
  def port_key; end

  class << self
    # source://capybara//lib/capybara/server.rb#56
    def ports; end
  end
end

# source://capybara//lib/capybara/server.rb#8
class Capybara::Server::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://capybara//lib/capybara/server.rb#28
  def initialize(app, server_errors); end

  # source://capybara//lib/capybara/server.rb#38
  def call(env); end

  # Returns the value of attribute error.
  #
  # source://capybara//lib/capybara/server.rb#26
  def error; end

  # Sets the attribute error
  #
  # @param value the value to set the attribute error to.
  #
  # source://capybara//lib/capybara/server.rb#26
  def error=(_arg0); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/server.rb#34
  def pending_requests?; end
end

# source://capybara//lib/capybara/server.rb#9
class Capybara::Server::Middleware::Counter
  # @return [Counter] a new instance of Counter
  #
  # source://capybara//lib/capybara/server.rb#12
  def initialize; end

  # source://capybara//lib/capybara/server.rb#21
  def decrement; end

  # source://capybara//lib/capybara/server.rb#17
  def increment; end

  # Returns the value of attribute value.
  #
  # source://capybara//lib/capybara/server.rb#10
  def value; end
end

# The Session class represents a single user's interaction with the system. The Session can use
# any of the underlying drivers. A session can be initialized manually like this:
#
#     session = Capybara::Session.new(:culerity, MyRackApp)
#
# The application given as the second argument is optional. When running Capybara against an external
# page, you might want to leave it out:
#
#     session = Capybara::Session.new(:culerity)
#     session.visit('http://www.google.com')
#
# When Capybara.threadsafe == true the sessions options will be initially set to the
# current values of the global options and a configuration block can be passed to the session initializer.
# For available options see {Capybara::SessionConfig::OPTIONS}
#
#     session = Capybara::Session.new(:driver, MyRackApp) do |config|
#       config.app_host = "http://my_host.dev"
#     end
#
# Session provides a number of methods for controlling the navigation of the page, such as +visit+,
# +current_path, and so on. It also delegate a number of methods to a Capybara::Document, representing
# the current HTML document. This allows interaction:
#
#     session.fill_in('q', with: 'Capybara')
#     session.click_button('Search')
#     expect(session).to have_content('Capybara')
#
# When using capybara/dsl, the Session is initialized automatically for you.
#
# source://capybara//lib/capybara/session.rb#38
class Capybara::Session
  include ::Capybara::SessionMatchers

  # @raise [TypeError]
  # @return [Session] a new instance of Session
  #
  # source://capybara//lib/capybara/session.rb#78
  def initialize(mode, app = T.unsafe(nil)); end

  # Execute the block, accepting a alert.
  #
  # Expects a block whose actions will trigger the display modal to appear
  #
  # @example
  #   accept_alert do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload accept_alert
  # @overload accept_alert
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  #
  # source://capybara//lib/capybara/session.rb#682
  def accept_alert(text_or_options = T.unsafe(nil), options = T.unsafe(nil), &blk); end

  # Execute the block, accepting a confirm.
  #
  # Expects a block whose actions will trigger the display modal to appear
  #
  # @example
  #   accept_confirm do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload accept_confirm
  # @overload accept_confirm
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  #
  # source://capybara//lib/capybara/session.rb#692
  def accept_confirm(text_or_options = T.unsafe(nil), options = T.unsafe(nil), &blk); end

  # Execute the block, accepting a prompt, optionally responding to the prompt.
  #
  # Expects a block whose actions will trigger the display modal to appear
  #
  # @example
  #   accept_prompt do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @option options
  # @overload accept_prompt
  # @overload accept_prompt
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  #
  # source://capybara//lib/capybara/session.rb#713
  def accept_prompt(text_or_options = T.unsafe(nil), options = T.unsafe(nil), &blk); end

  # source://capybara//lib/capybara/session.rb#806
  def all(*args, &block); end

  # Returns the value of attribute app.
  #
  # source://capybara//lib/capybara/session.rb#75
  def app; end

  # source://capybara//lib/capybara/session.rb#806
  def assert_all_of_selectors(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def assert_no_selector(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def assert_no_text(*args, &block); end

  # source://capybara//lib/capybara/session.rb#813
  def assert_no_title(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def assert_none_of_selectors(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def assert_selector(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def assert_text(*args, &block); end

  # source://capybara//lib/capybara/session.rb#813
  def assert_title(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def attach_file(*args, &block); end

  # @return [String] A snapshot of the DOM of the current document, as it looks right now (potentially modified by JavaScript).
  #
  # source://capybara//lib/capybara/session.rb#180
  def body; end

  # source://capybara//lib/capybara/session.rb#806
  def check(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def choose(*args, &block); end

  # Reset the session (i.e. remove cookies and navigate to blank page)
  #
  # This method does not:
  #
  #   * accept modal dialogs if they are present (Selenium driver now does, others may not)
  #   * clear browser cache/HTML 5 local storage/IndexedDB/Web SQL database/etc.
  #   * modify state of the driver/underlying browser in any other way
  #
  # as doing so will result in performance downsides and it's not needed to do everything from the list above for most apps.
  #
  # If you want to do anything from the list above on a general basis you can:
  #
  #   * write RSpec/Cucumber/etc. after hook
  #   * monkeypatch this method
  #   * use Ruby's `prepend` method
  #
  # source://capybara//lib/capybara/session.rb#125
  def cleanup!; end

  # source://capybara//lib/capybara/session.rb#806
  def click_button(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def click_link(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def click_link_or_button(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def click_on(*args, &block); end

  # source://capybara//lib/capybara/session.rb#860
  def config; end

  # Accepts a block to set the configuration options if Capybara.threadsafe == true. Note that some options only have an effect
  #  if set at initialization time, so look at the configuration block that can be passed to the initializer too
  #
  # @yield [config]
  #
  # source://capybara//lib/capybara/session.rb#851
  def configure; end

  # @return [String] Host of the current page
  #
  # source://capybara//lib/capybara/session.rb#207
  def current_host; end

  # @return [String] Path of the current page, without any domain information
  #
  # source://capybara//lib/capybara/session.rb#190
  def current_path; end

  # source://capybara//lib/capybara/session.rb#822
  def current_scope; end

  # @return [String] Fully qualified URL of the current page
  #
  # source://capybara//lib/capybara/session.rb#216
  def current_url; end

  # @return [Capybara::Window] current window
  #
  # source://capybara//lib/capybara/session.rb#450
  def current_window; end

  # Execute the block, dismissing a confirm.
  #
  # Expects a block whose actions will trigger the display modal to appear
  #
  # @example
  #   dismiss_confirm do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload dismiss_confirm
  # @overload dismiss_confirm
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  #
  # source://capybara//lib/capybara/session.rb#702
  def dismiss_confirm(text_or_options = T.unsafe(nil), options = T.unsafe(nil), &blk); end

  # Execute the block, dismissing a prompt.
  #
  # Expects a block whose actions will trigger the display modal to appear
  #
  # @example
  #   dismiss_prompt do
  #   click_link('link that triggers appearance of system modal')
  #   end
  # @overload dismiss_prompt
  # @overload dismiss_prompt
  # @raise [Capybara::ModalNotFound] if modal dialog hasn't been found
  # @return [String] the message shown in the modal
  #
  # source://capybara//lib/capybara/session.rb#723
  def dismiss_prompt(text_or_options = T.unsafe(nil), options = T.unsafe(nil), &blk); end

  # source://capybara//lib/capybara/session.rb#801
  def document; end

  # source://capybara//lib/capybara/session.rb#95
  def driver; end

  # Evaluate the given JavaScript and obtain the result from a callback function which will be passed as the last argument to the script.
  #
  # @param script [String] A string of JavaScript to evaluate
  # @return [Object] The result of the evaluated JavaScript (may be driver specific)
  #
  # source://capybara//lib/capybara/session.rb#650
  def evaluate_async_script(script, *args); end

  # Evaluate the given JavaScript and return the result. Be careful when using this with
  # scripts that return complex objects, such as jQuery statements. +execute_script+ might
  # be a better alternative.
  #
  # @param script [String] A string of JavaScript to evaluate
  # @return [Object] The result of the evaluated JavaScript (may be driver specific)
  #
  # source://capybara//lib/capybara/session.rb#632
  def evaluate_script(script, *args); end

  # Execute the given script, not returning a result. This is useful for scripts that return
  # complex objects, such as jQuery statements. +execute_script+ should be used over
  # +evaluate_script+ whenever possible.
  #
  # @param script [String] A string of JavaScript to execute
  # @param args Optional arguments that will be passed to the script.  Driver support for this is optional and types of objects supported may differ between drivers
  #
  # source://capybara//lib/capybara/session.rb#613
  def execute_script(script, *args); end

  # source://capybara//lib/capybara/session.rb#806
  def field_labeled(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def fill_in(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def find(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def find_all(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def find_button(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def find_by_id(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def find_field(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def find_link(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def first(*args, &block); end

  # Move back a single entry in the browser's history.
  #
  # source://capybara//lib/capybara/session.rb#290
  def go_back; end

  # Move forward a single entry in the browser's history.
  #
  # source://capybara//lib/capybara/session.rb#298
  def go_forward; end

  # source://capybara//lib/capybara/session.rb#806
  def has_button?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_checked_field?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_content?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_css?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_field?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_link?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_button?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_checked_field?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_content?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_css?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_field?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_link?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_select?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_selector?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_table?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_text?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#813
  def has_no_title?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_unchecked_field?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_no_xpath?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_select?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_selector?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_table?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_text?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#813
  def has_title?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_unchecked_field?(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def has_xpath?(*args, &block); end

  # @return [String] A snapshot of the DOM of the current document, as it looks right now (potentially modified by JavaScript).
  #
  # source://capybara//lib/capybara/session.rb#180
  def html; end

  # source://capybara//lib/capybara/session.rb#818
  def inspect; end

  # Returns the value of attribute mode.
  #
  # source://capybara//lib/capybara/session.rb#75
  def mode; end

  # Open new window.
  # Current window doesn't change as the result of this call.
  # It should be switched to explicitly.
  #
  # @return [Capybara::Window] window that has been opened
  #
  # source://capybara//lib/capybara/session.rb#474
  def open_new_window; end

  # source://capybara//lib/capybara/session.rb#806
  def query(*args, &block); end

  # Raise errors encountered in the server
  #
  # source://capybara//lib/capybara/session.rb#140
  def raise_server_error!; end

  # Refresh the page
  #
  # source://capybara//lib/capybara/session.rb#281
  def refresh; end

  # source://capybara//lib/capybara/session.rb#806
  def refute_selector(*args, &block); end

  # Reset the session (i.e. remove cookies and navigate to blank page)
  #
  # This method does not:
  #
  #   * accept modal dialogs if they are present (Selenium driver now does, others may not)
  #   * clear browser cache/HTML 5 local storage/IndexedDB/Web SQL database/etc.
  #   * modify state of the driver/underlying browser in any other way
  #
  # as doing so will result in performance downsides and it's not needed to do everything from the list above for most apps.
  #
  # If you want to do anything from the list above on a general basis you can:
  #
  #   * write RSpec/Cucumber/etc. after hook
  #   * monkeypatch this method
  #   * use Ruby's `prepend` method
  #
  # source://capybara//lib/capybara/session.rb#125
  def reset!; end

  # Reset the session (i.e. remove cookies and navigate to blank page)
  #
  # This method does not:
  #
  #   * accept modal dialogs if they are present (Selenium driver now does, others may not)
  #   * clear browser cache/HTML 5 local storage/IndexedDB/Web SQL database/etc.
  #   * modify state of the driver/underlying browser in any other way
  #
  # as doing so will result in performance downsides and it's not needed to do everything from the list above for most apps.
  #
  # If you want to do anything from the list above on a general basis you can:
  #
  #   * write RSpec/Cucumber/etc. after hook
  #   * monkeypatch this method
  #   * use Ruby's `prepend` method
  #
  # source://capybara//lib/capybara/session.rb#125
  def reset_session!; end

  # source://capybara//lib/capybara/session.rb#806
  def resolve(*args, &block); end

  # Returns a hash of response headers. Not supported by all drivers (e.g. Selenium)
  #
  # @return [Hash{String => String}] A hash of response headers.
  #
  # source://capybara//lib/capybara/session.rb#162
  def response_headers; end

  # Save a snapshot of the page and open it in a browser for inspection.
  #
  # If invoked without arguments it will save file to `Capybara.save_path`
  #   and file will be given randomly generated filename. If invoked with a relative path
  #   the path will be relative to `Capybara.save_path`, which is different from
  #   the previous behavior with `Capybara.save_and_open_page_path` where the relative path was
  #   relative to Dir.pwd
  #
  # @param path [String] the path to where it should be saved
  #
  # source://capybara//lib/capybara/session.rb#759
  def save_and_open_page(path = T.unsafe(nil)); end

  # Save a screenshot of the page and open it for inspection.
  #
  # If invoked without arguments it will save file to `Capybara.save_path`
  #   and file will be given randomly generated filename. If invoked with a relative path
  #   the path will be relative to `Capybara.save_path`, which is different from
  #   the previous behavior with `Capybara.save_and_open_page_path` where the relative path was
  #   relative to Dir.pwd
  #
  # @param path [String] the path to where it should be saved
  # @param options [Hash] a customizable set of options
  #
  # source://capybara//lib/capybara/session.rb#796
  def save_and_open_screenshot(path = T.unsafe(nil), options = T.unsafe(nil)); end

  # Save a snapshot of the page. If `Capybara.asset_host` is set it will inject `base` tag
  #   pointing to `asset_host`.
  #
  # If invoked without arguments it will save file to `Capybara.save_path`
  #   and file will be given randomly generated filename. If invoked with a relative path
  #   the path will be relative to `Capybara.save_path`, which is different from
  #   the previous behavior with `Capybara.save_and_open_page_path` where the relative path was
  #   relative to Dir.pwd
  #
  # @param path [String] the path to where it should be saved
  # @return [String] the path to which the file was saved
  #
  # source://capybara//lib/capybara/session.rb#741
  def save_page(path = T.unsafe(nil)); end

  # Save a screenshot of page.
  #
  # If invoked without arguments it will save file to `Capybara.save_path`
  #   and file will be given randomly generated filename. If invoked with a relative path
  #   the path will be relative to `Capybara.save_path`, which is different from
  #   the previous behavior with `Capybara.save_and_open_page_path` where the relative path was
  #   relative to Dir.pwd
  #
  # @param path [String] the path to where it should be saved
  # @param options [Hash] a customizable set of options
  # @return [String] the path to which the file was saved
  #
  # source://capybara//lib/capybara/session.rb#777
  def save_screenshot(path = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/session.rb#806
  def select(*args, &block); end

  # Returns the value of attribute server.
  #
  # source://capybara//lib/capybara/session.rb#75
  def server; end

  # @return [String] A snapshot of the DOM of the current document, as it looks right now (potentially modified by JavaScript).
  #
  # source://capybara//lib/capybara/session.rb#180
  def source; end

  # Returns the current HTTP status code as an Integer. Not supported by all drivers (e.g. Selenium)
  #
  # @return [Integer] Current HTTP status code
  #
  # source://capybara//lib/capybara/session.rb#172
  def status_code; end

  # Switch to the given frame
  #
  # If you use this method you are responsible for making sure you switch back to the parent frame when done in the frame changed to.
  # Capybara::Session#within_frame is preferred over this method and should be used when possible.
  # May not be supported by all drivers.
  #
  # @overload switch_to_frame
  # @overload switch_to_frame
  # @overload switch_to_frame
  #
  # source://capybara//lib/capybara/session.rb#387
  def switch_to_frame(frame); end

  # @overload switch_to_window
  # @overload switch_to_window
  # @raise [Capybara::ScopeError] if this method is invoked inside `within` or
  #   `within_frame` methods
  # @raise [ArgumentError] if both or neither arguments were provided
  # @return [Capybara::Window] window that has been switched to
  #
  # source://capybara//lib/capybara/session.rb#496
  def switch_to_window(window = T.unsafe(nil), options = T.unsafe(nil), &window_locator); end

  # Returns the value of attribute synchronized.
  #
  # source://capybara//lib/capybara/session.rb#76
  def synchronized; end

  # Sets the attribute synchronized
  #
  # @param value the value to set the attribute synchronized to.
  #
  # source://capybara//lib/capybara/session.rb#76
  def synchronized=(_arg0); end

  # source://capybara//lib/capybara/session.rb#806
  def text(*args, &block); end

  # source://capybara//lib/capybara/session.rb#813
  def title(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def uncheck(*args, &block); end

  # source://capybara//lib/capybara/session.rb#806
  def unselect(*args, &block); end

  # Yield a block using a specific wait time
  #
  # source://capybara//lib/capybara/session.rb#832
  def using_wait_time(seconds); end

  # Navigate to the given URL. The URL can either be a relative URL or an absolute URL
  # The behaviour of either depends on the driver.
  #
  #     session.visit('/foo')
  #     session.visit('http://google.com')
  #
  # For drivers which can run against an external application, such as the selenium driver
  # giving an absolute URL will navigate to that page. This allows testing applications
  # running on remote servers. For these drivers, setting {Capybara.app_host} will make the
  # remote server the default. For example:
  #
  #     Capybara.app_host = 'http://google.com'
  #     session.visit('/') # visits the google homepage
  #
  # If {Capybara.always_include_port} is set to true and this session is running against
  # a rack application, then the port that the rack application is running on will automatically
  # be inserted into the URL. Supposing the app is running on port `4567`, doing something like:
  #
  #     visit("http://google.com/test")
  #
  # Will actually navigate to `http://google.com:4567/test`.
  #
  # @param visit_uri [#to_s] The URL to navigate to. The parameter will be cast to a String.
  #
  # source://capybara//lib/capybara/session.rb#246
  def visit(visit_uri); end

  # Get the window that has been opened by the passed block.
  # It will wait for it to be opened (in the same way as other Capybara methods wait).
  # It's better to use this method than `windows.last`
  # {https://dvcs.w3.org/hg/webdriver/raw-file/default/webdriver-spec.html#h_note_10 as order of windows isn't defined in some drivers}
  #
  # @option options
  # @param options [Hash]
  # @raise [Capybara::WindowError] if block passed to window hasn't opened window
  #   or opened more than one window
  # @return [Capybara::Window] the window that has been opened within a block
  #
  # source://capybara//lib/capybara/session.rb#589
  def window_opened_by(options = T.unsafe(nil), &block); end

  # Get all opened windows.
  # The order of windows in returned array is not defined.
  # The driver may sort windows by their creation time but it's not required.
  #
  # @return [Array<Capybara::Window>] an array of all windows
  #
  # source://capybara//lib/capybara/session.rb#461
  def windows; end

  # Executes the given block within the context of a node. `within` takes the
  # same options as `find`, as well as a block. For the duration of the
  # block, any command to Capybara will be handled as though it were scoped
  # to the given element.
  #
  #     within(:xpath, './/div[@id="delivery-address"]') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Just as with `find`, if multiple elements match the selector given to
  # `within`, an error will be raised, and just as with `find`, this
  # behaviour can be controlled through the `:match` and `:exact` options.
  #
  # It is possible to omit the first parameter, in that case, the selector is
  # assumed to be of the type set in Capybara.default_selector.
  #
  #     within('div#delivery-address') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Note that a lot of uses of `within` can be replaced more succinctly with
  # chaining:
  #
  #     find('div#delivery-address').fill_in('Street', with: '12 Main Street')
  #
  # @overload within
  # @overload within
  # @raise [Capybara::ElementNotFound] If the scope can't be found before time expires
  #
  # source://capybara//lib/capybara/session.rb#337
  def within(*args); end

  # Executes the given block within the context of a node. `within` takes the
  # same options as `find`, as well as a block. For the duration of the
  # block, any command to Capybara will be handled as though it were scoped
  # to the given element.
  #
  #     within(:xpath, './/div[@id="delivery-address"]') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Just as with `find`, if multiple elements match the selector given to
  # `within`, an error will be raised, and just as with `find`, this
  # behaviour can be controlled through the `:match` and `:exact` options.
  #
  # It is possible to omit the first parameter, in that case, the selector is
  # assumed to be of the type set in Capybara.default_selector.
  #
  #     within('div#delivery-address') do
  #       fill_in('Street', with: '12 Main Street')
  #     end
  #
  # Note that a lot of uses of `within` can be replaced more succinctly with
  # chaining:
  #
  #     find('div#delivery-address').fill_in('Street', with: '12 Main Street')
  #
  # @overload within
  # @overload within
  # @raise [Capybara::ElementNotFound] If the scope can't be found before time expires
  #
  # source://capybara//lib/capybara/session.rb#337
  def within_element(*args); end

  # Execute the given block within the a specific fieldset given the id or legend of that fieldset.
  #
  # @param locator [String] Id or legend of the fieldset
  #
  # source://capybara//lib/capybara/session.rb#354
  def within_fieldset(locator); end

  # Execute the given block within the given iframe using given frame, frame name/id or index.
  # May not be supported by all drivers.
  #
  # @overload within_frame
  # @overload within_frame
  # @overload within_frame
  #
  # source://capybara//lib/capybara/session.rb#420
  def within_frame(*args); end

  # Execute the given block within the a specific table given the id or caption of that table.
  #
  # @param locator [String] Id or caption of the table
  #
  # source://capybara//lib/capybara/session.rb#366
  def within_table(locator); end

  # This method does the following:
  #
  # 1. Switches to the given window (it can be located by window instance/lambda/string).
  # 2. Executes the given block (within window located at previous step).
  # 3. Switches back (this step will be invoked even if exception will happen at second step)
  #
  # @overload within_window
  # @overload within_window
  # @overload within_window
  # @raise [Capybara::ScopeError] if this method is invoked inside `within_frame` method
  # @return value returned by the block
  #
  # source://capybara//lib/capybara/session.rb#536
  def within_window(window_or_handle); end

  private

  # source://capybara//lib/capybara/session.rb#929
  def _find_frame(*args); end

  # @raise [Capybara::ScopeError]
  #
  # source://capybara//lib/capybara/session.rb#947
  def _switch_to_window(window = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://capybara//lib/capybara/session.rb#871
  def accept_modal(type, text_or_options, options, &blk); end

  # source://capybara//lib/capybara/session.rb#907
  def default_fn(extension); end

  # source://capybara//lib/capybara/session.rb#875
  def dismiss_modal(type, text_or_options, options, &blk); end

  # source://capybara//lib/capybara/session.rb#916
  def element_script_result(arg); end

  # source://capybara//lib/capybara/session.rb#879
  def modal_options(text_or_options, options); end

  # source://capybara//lib/capybara/session.rb#887
  def open_file(path); end

  # source://capybara//lib/capybara/session.rb#897
  def prepare_path(path, extension); end

  # source://capybara//lib/capybara/session.rb#912
  def scopes; end

  class << self
    # @return [Boolean]
    #
    # source://capybara//lib/capybara/session.rb#856
    def instance_created?; end
  end
end

# @api private
#
# source://capybara//lib/capybara/session.rb#56
Capybara::Session::DOCUMENT_METHODS = T.let(T.unsafe(nil), Array)

# source://capybara//lib/capybara/session.rb#73
Capybara::Session::DSL_METHODS = T.let(T.unsafe(nil), Array)

# source://capybara//lib/capybara/session.rb#69
Capybara::Session::MODAL_METHODS = T.let(T.unsafe(nil), Array)

# source://capybara//lib/capybara/session.rb#41
Capybara::Session::NODE_METHODS = T.let(T.unsafe(nil), Array)

# source://capybara//lib/capybara/session.rb#59
Capybara::Session::SESSION_METHODS = T.let(T.unsafe(nil), Array)

# source://capybara//lib/capybara/session/config.rb#5
class Capybara::SessionConfig
  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def always_include_port; end

  # source://capybara//lib/capybara/session/config.rb#11
  def always_include_port=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def app_host; end

  # @raise [ArgumentError]
  #
  # source://capybara//lib/capybara/session/config.rb#76
  def app_host=(url); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def asset_host; end

  # source://capybara//lib/capybara/session/config.rb#11
  def asset_host=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def automatic_label_click; end

  # source://capybara//lib/capybara/session/config.rb#11
  def automatic_label_click=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def automatic_reload; end

  # source://capybara//lib/capybara/session/config.rb#11
  def automatic_reload=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def default_host; end

  # @raise [ArgumentError]
  #
  # source://capybara//lib/capybara/session/config.rb#82
  def default_host=(url); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def default_max_wait_time; end

  # source://capybara//lib/capybara/session/config.rb#11
  def default_max_wait_time=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def default_selector; end

  # source://capybara//lib/capybara/session/config.rb#11
  def default_selector=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def enable_aria_label; end

  # source://capybara//lib/capybara/session/config.rb#11
  def enable_aria_label=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def exact; end

  # source://capybara//lib/capybara/session/config.rb#11
  def exact=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def exact_options; end

  # source://capybara//lib/capybara/session/config.rb#95
  def exact_options=(opt); end

  # source://capybara//lib/capybara/session/config.rb#11
  def exact_text; end

  # source://capybara//lib/capybara/session/config.rb#11
  def exact_text=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def ignore_hidden_elements; end

  # source://capybara//lib/capybara/session/config.rb#11
  def ignore_hidden_elements=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def match; end

  # source://capybara//lib/capybara/session/config.rb#11
  def match=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def raise_server_errors; end

  # source://capybara//lib/capybara/session/config.rb#11
  def raise_server_errors=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def run_server; end

  # source://capybara//lib/capybara/session/config.rb#11
  def run_server=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def save_and_open_page_path; end

  # source://capybara//lib/capybara/session/config.rb#88
  def save_and_open_page_path=(path); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def save_path; end

  # source://capybara//lib/capybara/session/config.rb#11
  def save_path=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def server_errors; end

  # source://capybara//lib/capybara/session/config.rb#71
  def server_errors=(errors); end

  # @return [String] The IP address bound by default server
  #
  # source://capybara//lib/capybara/session/config.rb#66
  def server_host; end

  # source://capybara//lib/capybara/session/config.rb#11
  def server_host=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def server_port; end

  # source://capybara//lib/capybara/session/config.rb#11
  def server_port=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def visible_text_only; end

  # source://capybara//lib/capybara/session/config.rb#11
  def visible_text_only=(_arg0); end

  # See {Capybara.configure}
  #
  # source://capybara//lib/capybara/session/config.rb#11
  def wait_on_first_by_default; end

  # source://capybara//lib/capybara/session/config.rb#11
  def wait_on_first_by_default=(_arg0); end

  private

  # source://capybara//lib/capybara/session/config.rb#101
  def initialize_copy(other); end
end

# source://capybara//lib/capybara/session/config.rb#6
Capybara::SessionConfig::OPTIONS = T.let(T.unsafe(nil), Array)

# source://capybara//lib/capybara/session/matchers.rb#3
module Capybara::SessionMatchers
  # Asserts that the page has the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option
  #
  # @option options
  # @option options
  # @option options
  # @overload assert_current_path
  # @overload assert_current_path
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  #
  # source://capybara//lib/capybara/session/matchers.rb#21
  def assert_current_path(path, options = T.unsafe(nil)); end

  # Asserts that the page doesn't have the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option
  #
  # @option options
  # @option options
  # @option options
  # @overload assert_no_current_path
  # @overload assert_no_current_path
  # @param options [Hash] a customizable set of options
  # @raise [Capybara::ExpectationNotMet] if the assertion hasn't succeeded during wait time
  # @return [true]
  #
  # source://capybara//lib/capybara/session/matchers.rb#35
  def assert_no_current_path(path, options = T.unsafe(nil)); end

  # Checks if the page has the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option
  #
  # @option options
  # @option options
  # @option options
  # @overload has_current_path?
  # @overload has_current_path?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/session/matchers.rb#48
  def has_current_path?(path, options = T.unsafe(nil)); end

  # Checks if the page doesn't have the given path.
  # By default, if passed a full url this will compare against the full url,
  # if passed a path only the path+query portion will be compared, if passed a regexp
  # the comparison will depend on the :url option
  #
  # @option options
  # @option options
  # @option options
  # @overload has_no_current_path?
  # @overload has_no_current_path?
  # @param options [Hash] a customizable set of options
  # @return [Boolean]
  #
  # source://capybara//lib/capybara/session/matchers.rb#63
  def has_no_current_path?(path, options = T.unsafe(nil)); end

  private

  # source://capybara//lib/capybara/session/matchers.rb#71
  def _verify_current_path(path, options); end
end

# source://capybara//lib/capybara.rb#17
class Capybara::UnselectNotAllowed < ::Capybara::CapybaraError; end

# source://capybara//lib/capybara/version.rb#3
Capybara::VERSION = T.let(T.unsafe(nil), String)

# The Window class represents a browser window.
#
# You can get an instance of the class by calling either of:
#
# * {Capybara::Session#windows}
# * {Capybara::Session#current_window}
# * {Capybara::Session#window_opened_by}
# * {Capybara::Session#switch_to_window}
#
# Note that some drivers (e.g. Selenium) support getting size of/resizing/closing only
#   current window. So if you invoke such method for:
#
#   * window that is current, Capybara will make 2 Selenium method invocations
#     (get handle of current window + get size/resize/close).
#   * window that is not current, Capybara will make 4 Selenium method invocations
#     (get handle of current window + switch to given handle + get size/resize/close + switch to original handle)
#
# source://capybara//lib/capybara/window.rb#21
class Capybara::Window
  # @api private
  # @return [Window] a new instance of Window
  #
  # source://capybara//lib/capybara/window.rb#29
  def initialize(session, handle); end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/window.rb#103
  def ==(other); end

  # Close window.
  #
  # If this method was called for window that is current, then after calling this method
  #   future invocations of other Capybara methods should raise
  #   `session.driver.no_such_window_error` until another window will be switched to.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window shouldn remain the same as it was before calling this method.
  #
  # source://capybara//lib/capybara/window.rb#66
  def close; end

  # @return [Boolean] whether the window is closed
  #
  # source://capybara//lib/capybara/window.rb#43
  def closed?; end

  # @return [Boolean] whether this window is the window in which commands are being executed
  #
  # source://capybara//lib/capybara/window.rb#49
  def current?; end

  # @return [Boolean]
  #
  # source://capybara//lib/capybara/window.rb#103
  def eql?(other); end

  # @return [Boolean] whether the window is not closed
  #
  # source://capybara//lib/capybara/window.rb#37
  def exists?; end

  # @return [String] a string that uniquely identifies window within session
  #
  # source://capybara//lib/capybara/window.rb#23
  def handle; end

  # source://capybara//lib/capybara/window.rb#108
  def hash; end

  # source://capybara//lib/capybara/window.rb#112
  def inspect; end

  # Maximize window.
  #
  # If a particular driver (e.g. headless driver) doesn't have concept of maximizing it
  #   may not support this method.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window shouldn remain the same as it was before calling this method.
  #
  # source://capybara//lib/capybara/window.rb#99
  def maximize; end

  # Resize window.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window shouldn remain the same as it was before calling this method.
  #
  # @param width [String] the new window width in pixels
  # @param height [String] the new window height in pixels
  #
  # source://capybara//lib/capybara/window.rb#87
  def resize_to(width, height); end

  # @return [Capybara::Session] session that this window belongs to
  #
  # source://capybara//lib/capybara/window.rb#26
  def session; end

  # Get window size.
  #
  # If this method was called for window that is not current, then after calling this method
  # current window shouldn remain the same as it was before calling this method.
  #
  # @return [Array<(Integer, Integer)>] an array with width and height
  #
  # source://capybara//lib/capybara/window.rb#76
  def size; end

  private

  # source://capybara//lib/capybara/window.rb#134
  def raise_unless_current(what); end

  # source://capybara//lib/capybara/window.rb#118
  def wait_for_stable_size(seconds = T.unsafe(nil)); end
end

# source://capybara//lib/capybara.rb#21
class Capybara::WindowError < ::Capybara::CapybaraError; end

# Patch XPath to allow a nil condition in where
#
# source://capybara//lib/capybara/selector/selector.rb#7
module XPath
  class << self
    # source://xpath/3.2.0/lib/xpath.rb#15
    def generate; end
  end
end

# source://capybara//lib/capybara/selector/selector.rb#8
class XPath::Renderer
  # source://xpath/3.2.0/lib/xpath/renderer.rb#9
  def initialize(type); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#55
  def anywhere(element_names); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#63
  def attribute(current, name); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#51
  def axis(current, name, element_names); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#71
  def binary_operator(name, left, right); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#47
  def child(current, element_names); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#18
  def convert_argument(argument); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#95
  def css(current, selector); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#43
  def descendant(current, element_names); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#106
  def function(name, *arguments); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#75
  def is(one, two); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#91
  def literal(node); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#13
  def render(node); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#28
  def string_literal(string); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#87
  def text(current); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#39
  def this_node; end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#102
  def union(*expressions); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#83
  def variable(name); end

  # source://capybara//lib/capybara/selector/selector.rb#10
  def where(on, condition); end

  private

  # source://xpath/3.2.0/lib/xpath/renderer.rb#122
  def valid_xml_name?(name); end

  # source://xpath/3.2.0/lib/xpath/renderer.rb#112
  def with_element_conditions(expression, element_names); end

  class << self
    # source://xpath/3.2.0/lib/xpath/renderer.rb#5
    def render(node, type); end
  end
end
